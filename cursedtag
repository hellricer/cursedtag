#!/usr/bin/env bash
#
# cursedtag - a console ID3 tag editor.

# default field names. inspired by mpd naming
: ${CURSEDTAG_FIELDS:="title artist albumartist album
                date track genre comment composer performer"}
: ${CURSEDTAG_DEFAULT_TEMPLATE:=}

# default colors
: ${CURSEDTAG_COLOR_ERROR:=$'\e[91m'}
: ${CURSEDTAG_COLOR_OPTION:=$'\e[34m'}
: ${CURSEDTAG_COLOR_STATUS:=$'\e[33m'}
: ${CURSEDTAG_COLOR_MARKED:=$'\e[32m'}
: ${CURSEDTAG_COLOR_SUCCESS:=$'\e[32m'}
: ${CURSEDTAG_COLOR_SELECTED:=$'\e[7m'}

# mapping of field ids to human readable labels
declare -A fieldmapping
fieldmapping=(
    [title]="Title"
    [artist]="Artist"
    [albumartist]="Album artist"
    [album]="Album"
    [date]="Year"
    [track]="Track"
    [genre]="Genre"
    [comment]="Comment"
    [composer]="Composer"
    [performer]="Performer"
)

# short specifiers used in scanner mode
declare -A specifiers
specifiers=(
    [title]=t
    [artist]=a
    [albumartist]=z
    [album]=b
    [date]=y
    [track]=n
    [genre]=g
    [comment]=c
    [composer]=p
    [performer]=P
)

# map fields to IDs used my mid3v2
declare -A mid3v2_mapping
mid3v2_mapping=(
    [TIT2]=title
    [TPE1]=artist
    [TPE2]=albumartist
    [TALB]=album
    [TDRC]=date
    [TRCK]=track
    [TCON]=genre
    [COMM]=comment
    [TCOM]=composer
    [TPE3]=performer
)

# map fields to IDs used my metaflac
declare -A metaflac_mapping
metaflac_mapping=(
    [TITLE]="title"
    [ARTIST]="artist"
    [ALBUMARTIST]="albumartist"
    [ALBUM]="album"
    [DATE]="date"
    [TRACKNUMBER]="track"
    [GENRE]="genre"
    [COMMENT]="comment"
    [COMPOSER]="composer"
    [PERFORMER]="performer"
)

declare -a fieldorder
fieldorder=(${CURSEDTAG_FIELDS//:/ })

# global variables
declare -A data
declare -A data_state

get_term_size() {
    # Get terminal size ('stty' is POSIX and always available).
    # This can't be done reliably across all bash versions in pure bash.
    read -r ROWS COLS < <(stty size)

    # Max items that fit in the scroll area (leaving first & last row empty)
    max_items=$((${ROWS%% *} - 2))
}

setup_terminal() {
    # Setup the terminal for the TUI.
    # '\e[?1049h': Use alternative screen buffer.
    # '\e[?7l':    Disable line wrapping.
    # '\e[?25l':   Hide the cursor.
    # '\e[2J':     Clear the screen.
    # '\e[1;Nr':   Limit scrolling to scrolling area.
    #              Also sets cursor to (0,0).
    printf '\e[?1049h\e[?7l\e[?25l\e[2J\e[1;%sr' "$max_items"

    # Hide echoing of user input
    stty -echo
}

reset_terminal() {
    # Reset the terminal to a useable state (undo all changes).
    # '\e[?7h':   Re-enable line wrapping.
    # '\e[?25h':  Unhide the cursor.
    # '\e[2J':    Clear the terminal.
    # '\e[;r':    Set the scroll region to its default value.
    #             Also sets cursor to (0,0).
    # '\e[?1049l: Restore main screen buffer.
    printf '\e[?7h\e[?25h\e[2J\e[;r\e[?1049l'

    # Show user input.
    stty echo
}

clear_screen() {
    # Only clear the scrolling window.
    # '\e[%sH':    Move cursor to bottom of scroll area.
    # '\e[9999C':  Move cursor to right edge of the terminal.
    # '\e[1J':     Clear screen to top left corner (from cursor up).
    # '\e[2J':     Clear the terminal.
    # '\e[1;%sr':  Clearing the screen resets the scroll region(?). Re-set it.
    #              Also sets cursor to (0,0).
    printf '\e[%sH\e[9999C\e[1J\e[2J\e[1;%sr' \
           "((ROWS - 2))" "$max_items"
}

clear_line() {
    printf "\e[${1}H\r%-${COLS}s" " "
}

move_cursor() {
    printf "\e[${1};${2:-1}H"
}

show_cursor() {
    printf '\e[?25h'
}

hide_cursor() {
    printf '\e[?25l'
}

array_contains() {
    local seeking=$1; shift
    local in=0
    for element; do
        if [[ $element == $seeking ]]; then
            return
        fi
    done
    false
}

convert_time() {
    local h=$(($1 / 3600))
    local h_remain=$(($1 & 3600))
    local m=$(($h_remain / 60))
    local s=$(($1 % 60))
    if (( h > 0 )); then
        printf "%02d:%02d:%02.0f\n" $h $m $s
    else
        printf "%02d:%02.0f\n" $m $s
    fi
}

strindex() {
    local x="${1%%$2*}"
    [[ "$x" = "$1" ]] && echo -1 || echo "${#x}"
}

arrayindex() {
    local field=$1
    local -n givenList=$2
    local tag=
    for i in "${!givenList[@]}"; do
        if [[ ${givenList[$i]} == $field ]]; then
            tag=$i
            break
        fi
    done
    echo $tag
}

join_by() {
    local IFS="$1"; shift; echo "$*";
}

ellipsis() {
    local i=$1
    local n=$((${#i} + $2))
    if [[ ${n} -ge $COLS ]]; then
        len=$(($COLS))
        i=${i::$len}
        i="$i""…"
    fi
    printf -- "$i"
}

print_status_line() {
    local others=""
    local files=$(($# - 1))
    if [[ $# -gt 1 ]]; then
        others=" [and $files others]"
    fi
    move_cursor 0
    status="${1}${others}"
    short=$(ellipsis "$status" 0)
    printf '%s%s\e[0m\n' "${CURSEDTAG_COLOR_STATUS}" "$short"
}

print_option() {
    local option_color=$CURSEDTAG_COLOR_OPTION
    local mark_color=$CURSEDTAG_COLOR_MARKED
    local mark_symbol=" "
    if $1; then  # if marked
        mark_symbol="*"
        option_color=$CURSEDTAG_COLOR_MARKED
    fi
    if $2; then  # if selected
        option_color=$CURSEDTAG_COLOR_SELECTED
    fi
    printf '%s%s%s%s' $mark_color "$mark_symbol" $option_color "$3"
    printf '\e[0m'
}

editor_prompt() {
    local append=$1
    local y=$2
    local x=$(($3 + 6))
    local input=$4
    local original=$input
    local field_width=$(($COLS - $x + 1))
    local input_width=$(($field_width - 1))

    local cursor=0
    local cursor_offset=0
    if $append; then
        cursor=${#input}
        cursor_offset=0
        if (( ${#input} > $input_width )); then
            cursor=$input_width
            cursor_offset=$((${#input} - $input_width))
        fi
    fi

    while true; do
        local position=$(($cursor_offset + $cursor))

        hide_cursor
        # erase input part of the field
        move_cursor $y $(($x - 1))
        printf "%${field_width}s\r" " "

        move_cursor $y $x
        ln=$(($input_width + 1))
        local dots=" "
        if (( cursor_offset + input_width < ${#input} )); then
            dots="…"
        fi
        printf -- "${input:$cursor_offset:$ln}${dots}"
        move_cursor $y $(($x + $cursor))
        show_cursor

        # catch multi-char special key sequences
        read -sN1 key
        read -sN1 -t 0.0001 k1
        read -sN1 -t 0.0001 k2
        read -sN1 -t 0.0001 k3
        key+=${k1}${k2}${k3}
        case "$key" in
            $'\e[D')
                # left arrow
                if ((cursor > 0 )); then
                    ((cursor--))
                else
                    ((cursor_offset > 0)) && \
                        ((cursor_offset--))
                fi
                ;;
            $'\e[C') # right arrow
                if ((cursor + cursor_offset < ${#input} )); then
                    if ((cursor >= input_width)); then
                        ((cursor_offset++))
                    else
                        ((cursor++))
                    fi

                fi
                ;;
            $'\ca'|$'\e[1~'|$'\e0H'|$'\e[H') # home
                cursor=0
                cursor_offset=0
                ;;
            $'\h'|$'\b') # ctrl+backspace
                cursor=0
                cursor_offset=0
                input=""
                ;;
            $'\ce'|$'\e[4~'|$'\e0F'|$'\e[F') # end
                cursor=${#input}
                cursor_offset=0
                if (( ${#input} > input_width )); then
                    cursor=$input_width
                    cursor_offset=$((${#input} - $input_width))
                fi
                ;;
            $'\x7f'|$'\177') # backspace
                if (( position > 0)); then
                    r=$(($position - 1))
                    input=${input:0:$r}${input:$position:${#input}}
                    if ((cursor > 0 )); then
                        ((cursor--))
                    else
                        ((cursor_offset > 0)) && \
                            ((cursor_offset--))
                    fi
                fi
                ;;
            $'\e[3~') # delete
                l=$(($position + 1))
                input=${input:0:$position}${input:$l:${#input}}
                if (( cursor_offset > 0 )); then
                    cursor=$(($cursor + 1))
                    cursor_offset=$(($cursor_offset -1))
                fi
                ;;
            ''|$'\n')
                break
                ;;
            $'\x1b') # escape
                input=$original
                break
                ;;
            *)
                if ! [[ $key =~ [[:cntrl:]] ]]; then
                    input=${input:0:$position}$key${input:$position:${#input}}
                    if (( cursor < input_width )); then
                        cursor=$(($cursor + ${#key}))
                    else
                        cursor_offset=$(($cursor_offset + ${#key}))
                    fi
                fi
                ;;
        esac
    done

    editor_prompt_output=$input
}


start_selector() {
    local selected=1
    local select_all=0

    local marked=()

    local offset=1
    local lastoffset=0
    local page_step=$(( $ROWS - 3 ))

    local idx=1
    if [[ -n $preselected ]]; then
        for opt; do
            if [[ $opt == $preselected ]]; then
                selected=$idx
                offset=$(( $idx - max_items + 1 ))
                offset=$(( $offset > 1 ? $offset : 1 ))
                break
            fi
            ((idx++))
        done
    fi

    local clear=false
    while true; do
        if $clear || [[ $lastoffset != $offset ]]; then
            hide_cursor
            clear_screen
            print_status_line "${PWD##*/}"
            clear=false
        fi

        if $file_renamed; then
            file_renamed=false
            return
        fi

        idx=1
        lastoffset=$offset
        for opt; do
            if ((idx >= offset)) && ((idx < offset + max_items)); then
                move_cursor $((2 - $offset + $idx))  # starting at 2nd row
                local is_selected=false
                local is_marked=false
                [[ $idx == $selected ]] && \
                    is_selected=true
                array_contains $idx ${marked[@]} && \
                    is_marked=true
                local short=$(ellipsis " $opt " 2)
                print_option "$is_marked" "$is_selected" "$short"
            fi
            ((idx++))
        done

        # catch multi-char special key sequences
        read -sN1 key
        read -sN1 -t 0.0001 k1
        read -sN1 -t 0.0001 k2
        read -sN1 -t 0.0001 k3
        key+=${k1}${k2}${k3}
        case "$key" in
            k|$'\e[A')  # up arrow
                if (( selected > 1 )); then
                    ((selected--))
                    if (( selected < offset )); then
                        ((offset--))
                    fi
                fi
                ;;
            j|$'\e[B')  # down arrow
                if (( selected < $# )); then
                    ((selected++))
                    if (( selected > offset + max_items - 1 )); then
                        ((offset++))
                    fi
                fi
                ;;
            $'\cb'|$'\e[5~')  # ctrl+b, page up
                if (( selected - page_step > 1 )); then
                    ((selected-=page_step))
                    if (( selected < offset )); then
                        ((offset-=page_step))
                    fi
                else
                    selected=1
                    offset=1
                fi
                ;;
            $'\cf'|$'\e[6~')  # ctrl+f, page down
                if (( selected + page_step < $# )); then
                    ((selected+=page_step))
                    if (( selected > offset + max_items - 1 )); then
                        ((offset+=page_step))
                    fi
                else
                    selected=$#
                    ((offset=$# - max_items + 1))
                    offset=$(( $offset > 1 ? $offset : 1 ))
                fi
                ;;
            g|$'\e[1~'|$'\e0H'|$'\e[H')  # home
                selected=1
                offset=1
                ;;
            G|$'\e[4~'|$'\e0F'|$'\e[F')  # end
                selected=$#
                ((offset=$# - max_items + 1))
                offset=$(( $offset > 1 ? $offset : 1 ))
                ;;
            a|A|$'\ca'|$'\x01')  # ctrl+a
                ((select_all ^= 1))
                marked=()
                ((select_all == 1)) && \
                    marked=( $(seq 1 $(($idx - 1))) )
                ;;
            ' '|$'\x09')  # tab
                local found=false
                for i in ${!marked[@]}; do
                    if [[ ${marked[i]} == $selected ]]; then
                        found=true
                        unset 'marked[i]'
                    fi
                done
                if ! $found; then
                    marked+=( $selected )
                fi
                ;;
            e|l|$'\n'|$'\e[C') # enter, right arrow
                local marked_strings=()
                for m in ${marked[@]}; do
                    (( m != selected )) && marked_strings+=("${!m}")
                done
                start_editor "${!selected}" "${marked_strings[@]}"
                clear=true
                ;;
            r)
                local marked_strings=()
                for m in ${marked[@]}; do
                    (( m != selected )) && marked_strings+=("${!m}")
                done
                start_scanner true "${!selected}" "${marked_strings[@]}"
                clear=true
                ;;
            f)
                local marked_strings=()
                for m in ${marked[@]}; do
                    (( m != selected )) && marked_strings+=("${!m}")
                done
                start_scanner false "${!selected}" "${marked_strings[@]}"
                clear=true
                ;;
            q|$'\x1b')
                clean_exit
                ;;
        esac
    done
}

bulk_rename() {
    local template=$1; shift
    for opt; do
        local extension="${opt##*.}"
        local newname=$template

        # read data
        data=()
        read_data "$opt"
        declare -A fields=()
        for field in "${!data[@]}"; do
            if [[ -v "specifiers[$field]" ]]; then
                local specifier=${specifiers[$field]}
                if ! [[ -v "fields[$specifier]" ]]; then
                    fields[$specifier]=${data[$field]}
                fi
            fi
        done

        # replace specifiers with data
        for s in ${specifiers[@]}; do
            if [[ $input =~ .*%${s}.* ]]; then
                local substitution=$(echo ${fields[$s]} | \
                    sed -e 's/&/\\&/g' -e 's;/;\\/;g')
                newname=$(echo $newname | sed "s/%${s}/${substitution}/g")
            fi
        done

        echo "   $opt"
        echo -n "-> $newname.$extension :"
        newname=${newname/#~/$HOME}  # tilde expansion
        if [[ -z "${newname// }" ]]; then
            printf "%s empty file name. \e[0m\n\n" $CURSEDTAG_COLOR_ERROR
        elif [[ $opt == "$newname.$extension" ]]; then
            echo -e "-> unchanged\n"
        elif [[ -f "$newname.$extension" ]]; then
            printf "%s file exists. \e[0m\n\n" $CURSEDTAG_COLOR_ERROR
        else
            mkdir -p -- "$(dirname -- "$newname")"
            mv -n -- "$opt" "$newname.$extension" &> /dev/null
            if [[ $? -ne 0 ]]; then
                printf "%s could not rename. \e[0m\n\n" \
                $CURSEDTAG_COLOR_ERROR
            else
                printf "%s renamed. \e[0m\n\n" $CURSEDTAG_COLOR_SUCCESS
                preselected=$newname.$extension
                file_renamed=true
            fi
        fi
    done
}

fill_tags() {
    local template=$1; shift
    for opt; do
        local regexp="$(echo $template | \
                    sed -e 's,/,\\/,g ; s,|,\\|,g' \
                    -e 's/(/\\(/g ; s/)/\\)/g ; s/\[/\\[/g ; s/\]/\\]/g')"
        local order_of_specifiers=()
        for tag in ${!specifiers[@]}; do
            local specifier=${specifiers[$tag]}
            if [[ $template =~ .*%${specifier}.* ]]; then
                local x=$(strindex "$template" "%${specifier}")
                regexp="$(echo $regexp | sed "s/%${specifier}/\(.*?\)/g")"
                if (( x >= 0 )); then
                    order_of_specifiers[$x]=$tag
                fi
            fi
        done

        local idx=1
        replacement=()
        for tag in ${order_of_specifiers[@]}; do
            replacement+=("${tag}=\\${idx}")
            ((idx++))
        done
        replacement=$(join_by "^" "${replacement[@]}")
        local parent_name=""
        local parent=""
        local filename="${opt%.*}"
        local slashes=$(echo $regexp | awk -F '/' '{print NF-1}')
        ((slashes > 0 )) && for i in $(seq 1 $slashes); do
            parent_name="$(basename -- ${parent:-$PWD})"
            if ! [[ $parent_name == "/" ]]; then
                filename=${parent_name}/${filename}
            else
                filename=/$filename
                break
            fi
            parent=$(dirname -- ${parent:-$PWD})
        done
        if [[ -n "$replacement" ]]; then
            local output=$(echo $filename | \
                perl -ne "print if s|^${regexp}$|${replacement}|")
            if [[ -n "$output" ]]; then
                while IFS= read -r -d '^' line; do
                    local field=${line%=*}
                    local value=${line##*=}
                    set_field "$field" "$value" "$opt"
                done <<< "${output}^"
            fi
        fi
    done
}

start_scanner() {
    local rename_mode=$1; shift
    local input=${CURSEDTAG_DEFAULT_TEMPLATE}
    local cursor=${#input}
    local preview=""

    # read data
    data=()
    read_data "$1"
    declare -A fields=()
    for field in "${!data[@]}"; do
        if [[ -v "specifiers[$field]" ]]; then
            local specifier=${specifiers[$field]}
            if ! [[ -v "fields[$specifier]" ]]; then
                fields[$specifier]=${data[$field]}
            fi
        fi
    done

    local legend=()
    for s in ${!specifiers[@]}; do
        legend+=("%${specifiers[$s]}: ${fieldmapping[$s]}")
    done
    IFS=$'\n' sorted_legend=($(sort <<< "${legend[*]}"))

    hide_cursor
    clear_screen
    print_status_line "$@"

    move_cursor 5
    printf "Legend\n"
    for n in ${sorted_legend[@]}; do
        printf "  %s\n" "$n"
    done

    while true; do
        if $rename_mode; then
            preview=$input
            # replace specifiers with data
            for s in ${specifiers[@]}; do
                if [[ $preview =~ .*%${s}.* ]]; then
                    local substitution=$(echo ${fields[$s]} |\
                        sed -e 's/&/\\&/g' -e 's;/;\\/;g')
                    if [[ -z $substitution ]]; then
                        substitution="[…]"
                    fi
                    preview=$(echo $preview | \
                        sed "s/%${s}/$substitution/g" | \
                        fold -w ${COLS} -s)
                fi
            done
        else
            # parse filename according to template
            preview=""
            local regexp="$(echo $input | \
                    sed -e 's,/,\\/,g ; s,|,\\|,g' \
                    -e 's/(/\\(/g ; s/)/\\)/g ; s/\[/\\[/g ; s/\]/\\]/g')"
            local order=()
            for s in ${specifiers[@]}; do
                if [[ $input =~ .*%${s}.* ]]; then
                    local x=$(strindex "$input" "%${s}")
                    regexp="$(echo $regexp | sed "s/%${s}/\(.*?\)/g")"
                    if (( x >= 0 )); then
                        order[$x]=$s
                    fi
                fi
            done

            local idx=1
            local replacement=()
            for s in ${order[@]}; do
                replacement+=("%${s}=\\${idx}")
                ((idx++))
            done
            replacement=$(join_by " " "${replacement[@]}")
            local parent_name=""
            local parent=""
            local filename="${1%.*}"
            local slashes=$(echo $regexp | awk -F '/' '{print NF-1}')
            ((slashes > 0 )) && for i in $(seq 1 $slashes); do
                parent_name="$(basename -- ${parent:-$PWD})"
                if ! [[ $parent_name == "/" ]]; then
                    filename=${parent_name}/${filename}
                else
                    filename=/$filename
                    break
                fi
                parent=$(dirname -- ${parent:-$PWD})
            done
            if [[ -n "$replacement" ]]; then
                output=$(echo $filename | \
                    perl -ne "print if s|^${regexp}$|${replacement}|")
                [[ -n "$output" ]] && \
                    preview=$(echo $output | fold -w ${COLS} -s)
            fi
        fi

        # erase only lines that change to avoid too much clear_screen
        hide_cursor
        clear_line 2
        clear_line 3
        clear_line 4
        move_cursor 2
        printf " > %s\n" "$input"
        printf '   \e[32m%s\e[0m\n\n' "$preview"
        move_cursor 2 $((4 + $cursor))
        show_cursor

        # catch multi-char special key sequences
        read -sN1 key
        read -sN1 -t 0.0001 k1
        read -sN1 -t 0.0001 k2
        read -sN1 -t 0.0001 k3
        key+=${k1}${k2}${k3}
        case "$key" in
            $'\e[D')
                # left arrow
                ((cursor > 0 )) && ((cursor--))
                ;;
            $'\e[C') # right arrow
                ((cursor < ${#input} )) && ((cursor++))
                ;;
            $'\ca'|$'\e[1~'|$'\e0H'|$'\e[H') # home
                cursor=0
                ;;
            $'\ce'|$'\e[4~'|$'\e0F'|$'\e[F') # end
                cursor=${#input}
                ;;
            $'\x7f'|$'\177') # backspace
                if (( cursor > 0)); then
                    r=$(($cursor - 1))
                    input=${input:0:$r}${input:$cursor:${#input}}
                    cursor=$r
                fi
                ;;
            $'\h'|$'\b') # ctrl+backspace
                input=
                cursor=0
                ;;
            $'\e[3~') # delete
                l=$(($cursor + 1))
                input=${input:0:$cursor}${input:$l:${#input}}
                ;;
            ''|$'\n')
                break
                ;;
            $'\x1b') # escape
                return
                ;;
            *)
                if ! [[ $key =~ [[:cntrl:]] ]]; then
                    input=${input:0:$cursor}$key${input:$cursor:${#input}}
                    cursor=$(($cursor + ${#key}))
                fi
                ;;
        esac
    done

    # redraw the screen without legend
    clear_screen
    print_status_line "$@"
    printf " > %s\n" "$input"
    printf "   %s%s\e[0m\n" $CURSEDTAG_COLOR_SUCCESS "$preview"
    printf "\n"

    if $rename_mode; then
        bulk_rename "$input" "$@"
    else
        fill_tags "$input" "$@"
    fi

    echo
    echo " [Press enter...]"
    read
    return $returncode
}

read_data() {
    read_data_mid3v2 "$@"
    read_data_metaflac "$@"
    read_data_vorbiscomment "$@"
}

read_data_mid3v2() {
    local extension="${1##*.}"
    if [[ $extension == "mp3" ]]; then
        data[size]=$(du -h -- "$1" | awk '{print $1}')
        data[bitrate]=$(sox --i -B -- "$1" 2> /dev/null)
        local secs=$(sox --i -D -- "$1" 2> /dev/null)
        secs="${secs%%.*}"
        data[length]=$(convert_time $secs)

        while read line; do
            tag=$(echo $line | grep -ao "^....")
            value=$(echo $line | sed "s/[^ ]*=\(.*\)$/\1/")
            if [[ -v mid3v2_mapping[$tag] ]]; then
                local tagname="${mid3v2_mapping[$tag]}"
                if ! [[ -v "data[$tagname]" ]]; then
                    data[$tagname]=$value
                    data_state[$tagname]=$value
                fi
            fi
        done <<< $(mid3v2 -q -- "$1" | grep -a "^....=" | tr '\0' '=')
    fi
}

read_data_metaflac() {
    local extension="${1##*.}"
    if [[ $extension == "flac" ]]; then
        data[size]=$(du -h -- "$1" | awk '{print $1}')
        data[bitrate]=$(sox --i -B -- "$1" 2> /dev/null)
        local secs=$(sox --i -D -- "$1" 2> /dev/null)
        secs="${secs%%.*}"
        data[length]=$(convert_time $secs)

        while read line; do
            tag=$(echo $line | grep -ao "^[A-Z]*")
            value=$(echo $line | sed "s/[A-Z]*=//")
            if [[ -v metaflac_mapping[$tag] ]]; then
                local tagname="${metaflac_mapping[$tag]}"
                if ! [[ -v "data[$tagname]" ]]; then
                    data[$tagname]=$value
                    data_state[$tagname]=$value
                fi
            fi
        done <<< $(metaflac --list --except-block-type=PICTURE \
            -- "$1" | grep -ao "[A-Z]*=.*")
    fi
}

read_data_vorbiscomment() {
    local extension="${1##*.}"
    if [[ $extension == "ogg" ]]; then
        data[size]=$(du -h -- "$1" | awk '{print $1}')
        data[bitrate]=$(sox --i -B -- "$1" 2> /dev/null)
        local secs=$(sox --i -D -- "$1" 2> /dev/null)
        secs="${secs%%.*}"
        data[length]=$(convert_time $secs)

        while read line; do
            tag=$(echo $line | grep -ao "^[A-Z]*")
            value=$(echo $line | sed "s/[A-Z]*=//")
            if [[ -v metaflac_mapping[$tag] ]]; then
                local tagname="${metaflac_mapping[$tag]}"
                if ! [[ -v "data[$tagname]" ]]; then
                    data[$tagname]=$value
                    data_state[$tagname]=$value
                fi
            fi
        done <<< $(vorbiscomment -l -- "$1" | grep -ao "[A-Z]*=.*")
    fi
}

set_field() {
    set_field_mid3v2 "$@"
    set_field_metaflac "$@"
    set_field_vorbiscomment "$@"
}

set_field_mid3v2() {
    local field=$1; shift
    local value=$1; shift

    local tag=$(arrayindex $field mid3v2_mapping)
    local options=("--delete-frames" "$tag")
    if [[ -n "$value" ]]; then
        options+=("--$tag" "$value")
    fi

    local files=()
    for opt; do
        local extension="${opt##*.}"
        if [[ $extension == "mp3" ]]; then
            files+=("$opt")
        fi
    done
    if (( ${#options[@]} )) && (( ${#files[@]} )); then
        echo "mid3v2 "${options[@]}" -- \\"
        printf '    %s \\\n' "${files[@]}"
        mid3v2 "${options[@]}" -- "${files[@]}"
    fi
}

set_field_metaflac() {
    local field=$1; shift
    local value=$1; shift

    local tag=$(arrayindex $field metaflac_mapping)
    local options=("--remove-tag" "$tag")
    if [[ -n "$value" ]]; then
        options+=("--set-tag" "$tag=$value")
    fi

    local files=()
    for opt; do
        local extension="${opt##*.}"
        if [[ $extension == "flac" ]]; then
            files+=("$opt")
        fi
    done
    if (( ${#options[@]} )) && (( ${#files[@]} )); then
        echo "metaflac "${options[@]}" -- \\"
        printf '    %s \\\n' "${files[@]}"
        metaflac "${options[@]}" -- "${files[@]}"
    fi
}

set_field_vorbiscomment() {
    local field=$1; shift
    local value=$1; shift

    local tag=$(arrayindex $field metaflac_mapping)
    options=("--tag" "$tag=$value")

    local files=()
    for opt; do
        local extension="${opt##*.}"
        if [[ $extension == "ogg" ]]; then
            {
                vorbiscomment "$opt" | grep -v "^$tag"
                echo $tag="$value"
            } | vorbiscomment -c - -w -- "$opt"
            echo vorbiscomment -t "$field=$value" "$opt"
        fi
    done
}

start_editor() {
    local selected=1
    local offset=1
    local lastoffset=0

    local page_step=$(( $ROWS - 3 ))
    local list_size=${#fieldorder[@]}

    local is_yanked=false
    local yanked=""

    # read data
    data=()
    data_state=()
    read_data "$1"

    # get widest field name to create nice grid
    local max_field_length=0
    for s in ${fieldorder[@]}; do
        if [[ ${#fieldmapping[$s]} -gt $max_field_length ]]; then
            local max_field_length=${#fieldmapping[$s]}
        fi
    done
    ((max_field_length++))

    local clear=false
    while true; do
        local field_index=$(($selected - 1))
        local field=${fieldorder[$field_index]}

        # clear screen if the offset changed
        if $clear || [[ $lastoffset != $offset ]]; then
            hide_cursor
            clear_screen
            print_status_line "$@"
            clear=false
            printf "bitrate: %s%-4s\e[0m  " \
                $CURSEDTAG_COLOR_OPTION "${data[bitrate]}"
            printf "file size: %s%-4s\e[0m  "\
                $CURSEDTAG_COLOR_OPTION "${data[size]}"
            printf "length: %s%s\e[0m\n" \
                $CURSEDTAG_COLOR_OPTION "${data[length]}"
        fi

        # print options
        idx=1
        lastoffset=$offset
        for s in ${fieldorder[@]}; do
            if ((idx >= offset)) && ((idx < offset + max_items)); then
                local fieldname=${fieldmapping[$s]}
                local is_selected=false
                local is_unsaved=false
                [[ $idx == $selected ]] && \
                    is_selected=true
                if ! [[ "${data[$s]}" == "${data_state[$s]}" ]]; then
                    is_unsaved=true
                fi
                move_cursor $((3 - $offset + $idx))  # starting at 3nd row
                printf " %-${max_field_length}s: " "$fieldname"
                local dots=$(ellipsis " ${data_state[$s]} " ${max_field_length})
                print_option "$is_unsaved" "$is_selected" "$dots"
            fi
            ((idx++))
        done
        read -sN1 key
        read -sN1 -t 0.0001 k1
        read -sN1 -t 0.0001 k2
        read -sN1 -t 0.0001 k3
        key+=${k1}${k2}${k3}
        case "$key" in
            k|$'\e[A')  # up
                if (( selected > 1 )); then
                    ((selected--))
                    if (( selected < offset )); then
                        ((offset--))
                    fi
                fi
                ;;
            j|$'\e[B')  # down
                if (( selected < list_size )); then
                    ((selected++))
                    if (( selected > offset + max_items - 1 )); then
                        ((offset++))
                    fi
                fi
                ;;
            $'\cb'|$'\e[5~')  # page up
                if (( selected - page_step > 1 )); then
                    ((selected-=page_step))
                    if (( selected < offset )); then
                        ((offset-=page_step))
                    fi
                else
                    selected=1
                    offset=1
                fi
                ;;
            $'\cf'|$'\e[6~')  # page down
                if (( selected + page_step < list_size )); then
                    ((selected+=page_step))
                    if (( selected > offset + max_items - 1 )); then
                        ((offset+=page_step))
                    fi
                else
                    selected=$list_size
                    ((offset=list_size - max_items + 1))
                    offset=$(( $offset > 1 ? $offset : 1 ))
                fi
                ;;
            g|$'\e[1~'|$'\e0H'|$'\e[H')  # home
                selected=1
                offset=1
                ;;
            G|$'\e[4~'|$'\e0F'|$'\e[F')  # end
                selected=$list_size
                ((offset=list_size - max_items + 1))
                offset=$(( $offset > 1 ? $offset : 1 ))
                ;;
            i)  # edit (cursor at start)
                editor_prompt_output=""
                editor_prompt false $(($selected - $offset + 3)) \
                    $max_field_length "${data_state[$field]}"
                data_state[$field]=$editor_prompt_output
                hide_cursor
                clear_line $(($selected - $offset + 3))
                ;;
            a|$'\n') # edit (cursor at end)
                editor_prompt_output=""
                editor_prompt true $(($selected - $offset + 3)) \
                    ${max_field_length} "${data_state[$field]}"
                data_state[$field]=$editor_prompt_output
                hide_cursor
                clear_line $(($selected - $offset + 3))
                ;;
            y)  # yank
                yanked=${data_state[$field]}
                is_yanked=true
                ;;
            p)  # paste
                if $is_yanked; then
                    data_state[$field]=$yanked
                    clear_line $(($selected - $offset + 3))
                fi
                ;;
            x)  # erase
                data_state[$field]=""
                clear_line $(($selected - $offset + 3))
                ;;
            u)  # undo
                data_state[$field]=${data[$field]}
                clear_line $(($selected - $offset + 3))
                ;;
            S|W) # apply field to all files
                clear=true
                clear_screen
                print_status_line "$@"
                data[$field]=${data_state[$field]}
                set_field "$field" "${data_state[$field]}" "$@"
                echo
                echo " [Press enter...]"
                read
                ;;
            s|w) # save
                clear=true
                clear_screen
                print_status_line "$@"
                local setopts=()
                local delopts=()
                for n in "${!data_state[@]}"; do
                    if ! [[ "${data_state[$n]}" == "${data[$n]}" ]]; then
                        data[$n]=${data_state[$n]}
                        set_field "$n" "${data_state[$n]}" "$1"
                    fi
                done
                echo
                echo " [Press enter...]"
                read
                ;;
            h|$'\e[D'|$'\x1b')  # back to selector
                return
                ;;
            q) # quit
                clean_exit
                ;;
        esac
    done
}

clean_exit() {
    # ask for quit?
    reset_terminal
    show_cursor
    trap '' EXIT
    trap '' WINCH
    echo >&2 $2
    exit $1
}

start() {
    local file=$1; shift
    local path=$file

    get_term_size
    setup_terminal
    trap 'get_term_size; ' WINCH
    trap 'reset_terminal' EXIT

    if [[ -f "$file" ]]; then
        preselected=$(basename -- "$file")
    path=$(dirname -- "$file")
        start_editor "$file"
        clear
    fi

    builtin cd "$path"
    while true; do
        local audio_files=()
        # mp3 support check
        [[ -x "$(command -v mid3v2)" ]] && while IFS=  read -r -d $'\0'; do
            audio_files+=("$(basename -- "$REPLY")")
        done < <(find -maxdepth 1 -type f -name "*.mp3" -print0)

        # flac support check
        [[ -x "$(command -v metaflac)" ]] && while IFS=  read -r -d $'\0'; do
            audio_files+=("$(basename -- "$REPLY")")
        done < <(find -maxdepth 1 -type f -name "*.flac" -print0)

        # ogg support check
        [[ -x "$(command -v ogginfo)" ]] && while IFS=  read -r -d $'\0'; do
            audio_files+=("$(basename -- "$REPLY")")
        done < <(find -maxdepth 1 -type f -name "*.ogg" -print0)

        (( ${#audio_files[@]} )) || \
            clean_exit 1 "No supported audio files found."
        start_selector "${audio_files[@]}"
    done
}

# main
arg=${1:-"."}
if [[ -n "$arg" ]]; then
    if [[ -e "$arg" ]]; then
        start "$arg"
    else
        echo >&2 "File not found."
        exit 1
    fi
fi
