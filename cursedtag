#!/usr/bin/env bash
# shellcheck disable=SC2155
#
# cursedtag - a console audio tag editor.

# read configuration file
if [[ -f "${XDG_CONFIG_HOME:-$HOME/.config}/cursedtag/rc" ]]; then
    . "${XDG_CONFIG_HOME:-$HOME/.config}/cursedtag/rc"
fi

# default configuration. You can just paste these lines
# to the configuration file and customize.
: "${CURSEDTAG_COLOR_ERROR:=$'\e[91m'}"
: "${CURSEDTAG_COLOR_OPTION:=$'\e[34m'}"
: "${CURSEDTAG_COLOR_STATUS:=$'\e[33m'}"
: "${CURSEDTAG_COLOR_MARKED:=$'\e[32m'}"
: "${CURSEDTAG_COLOR_SUCCESS:=$'\e[32m'}"
: "${CURSEDTAG_COLOR_SELECTED:=$'\e[7m'}"
: "${CURSEDTAG_SYMBOL_MARKED:="*"}"
: "${CURSEDTAG_DEFAULT_TEMPLATE:=}"
: "${CURSEDTAG_FIELDS:="title artist albumartist album
                date track tracktotal genre comment composer performer"}"

# mapping of field ids to human readable labels
declare -A fieldmapping
fieldmapping=(
    [title]="Title"
    [artist]="Artist"
    [albumartist]="Album artist"
    [album]="Album"
    [date]="Year"
    [track]="Track"
    [genre]="Genre"
    [comment]="Comment"
    [composer]="Composer"
    [performer]="Performer"
    [tracktotal]="Number of tracks"
    # read-only fields
    [_filename]="Filename"
)

# short specifiers used in scanner mode
declare -A specifiers
specifiers=(
    [title]=t
    [artist]=a
    [albumartist]=z
    [album]=b
    [date]=y
    [track]=n
    [genre]=g
    [comment]=c
    [composer]=C
    [performer]=p
    [tracktotal]=l
    [_filename]=f
)

# map fields to IDs used my mid3v2
declare -A mid3v2_mapping
mid3v2_mapping=(
    [TIT2]=title
    [TPE1]=artist
    [TPE2]=albumartist
    [TALB]=album
    [TDRC]=date
    [TRCK]=track
    [TCON]=genre
    [COMM]=comment
    [TCOM]=composer
    [TPE3]=performer
    #[...]=tracktotal
)

# map fields to IDs used my metaflac & vorbiscomment
declare -A vorbis_mapping
vorbis_mapping=(
    [TITLE]=title
    [ARTIST]=artist
    [ALBUMARTIST]=albumartist
    [ALBUM]=album
    [DATE]=date
    [TRACKNUMBER]=track
    [GENRE]=genre
    [DESCRIPTION]=comment
    [COMPOSER]=composer
    [PERFORMER]=performer
    [TRACKTOTAL]=tracktotal
)

declare -a fieldorder
fieldorder=(${CURSEDTAG_FIELDS//:/ })

# global variables
declare -A data
declare -A data_state
declare yanked
declare max_items
declare max_columns
declare resized

get_term_size() {
    eval "$(resize)"

    # Max items that fit in the scroll area (leaving first row reserved for header)
    max_items=$((${LINES%% *} - 1))
    max_columns=$COLUMNS
    resized=true
}

setup_terminal() {
    # Setup the terminal for the TUI.
    # '\e[?1049h': Use alternative screen buffer.
    # '\e[?7l':    Disable line wrapping.
    # '\e[?25l':   Hide the cursor.
    # '\e[2J':     Clear the screen.
    # '\e[1;Nr':   Limit scrolling to scrolling area.
    #              Also sets cursor to (0,0).
    printf '\e[?1049h\e[?7l\e[?25l\e[2J\e[1;%sr' "$max_items"

    # Hide echoing of user input
    stty -echo
}

reset_terminal() {
    # Reset the terminal to a useable state (undo all changes).
    # '\e[?7h':   Re-enable line wrapping.
    # '\e[?25h':  Unhide the cursor.
    # '\e[2J':    Clear the terminal.
    # '\e[;r':    Set the scroll region to its default value.
    #             Also sets cursor to (0,0).
    # '\e[?1049l: Restore main screen buffer.
    printf '\e[?7h\e[?25h\e[2J\e[;r\e[?1049l'

    # Show user input.
    stty echo
}

clear_screen() {
    printf '\e[2J'
}

clear_line() {
    printf '\e[%s;%sH\e[0K' "$1" "${2:0}"
}

move_cursor() {
    printf '\e[%s;%sH' "$1" "${2:0}"
}

show_cursor() {
    printf '\e[?25h'
}

hide_cursor() {
    printf '\e[?25l'
}

array_contains() {
    local seeking=$1; shift
    for element; do
        if [[ $element == "$seeking" ]]; then
            return
        fi
    done
    false
}

basename() {
    : "${1%/}"
    printf '%s\n' "${_##*/}"
}

dirname() {
    [[ $1 = */* ]] && printf '%s\n' "${1%/*}" || printf '.\n'
}

convert_time() {
    local h=$(($1 / 3600))
    local h_remain=$(($1 & 3600))
    local m=$((h_remain / 60))
    local s=$(($1 % 60))
    if (( h > 0 )); then
        printf '%02d:%02d:%02.0f\n' $h $m $s
    else
        printf '%02d:%02.0f\n' $m $s
    fi
}

strindex() {
    local x="${1%%$2*}"
    [[ "$x" = "$1" ]] && echo -1 || echo "${#x}"
}

arrayindex() {
    local field=$1
    local -n givenList=$2
    local tag=
    for i in "${!givenList[@]}"; do
        if [[ ${givenList[$i]} == "$field" ]]; then
            tag=$i
            break
        fi
    done
    echo "$tag"
}

join_by() {
    local IFS="$1"; shift; echo "$*"
}

is_too_long() {
    local i=$1
    local n=$((${#i} + $2))
    if (( n >= max_columns )); then
        return 0
    fi
    return 1
}

zero_pad() {
    local number=$1
    local width=$2
    if [[ $number =~ ^[0-9]+$ ]]; then
        number=${number##+(0)}
        printf "%.0${width}d\n" "${number}"
    else
        printf "%s\n" "$number"
    fi
}

wait_for_key() {
    echo
    # clear stdin buffer
    while read -r -t 0; do read -r; done
    read -n 1 -s -r -p "[Press any key...]"
}

print_status_line() {
    local others=""
    local files=$(($# - 1))
    if [[ $# -gt 1 ]]; then
        others=" [and $files others]"
    fi
    move_cursor 0
    status="${1}${others}"
    printf '%s%s\e[0m\e[K' "$CURSEDTAG_COLOR_STATUS" "$status"
    if (( ${#status} >= max_columns )); then
        printf '…'
    fi
}

print_option() {
    local option_color=$CURSEDTAG_COLOR_OPTION
    local mark_color=$CURSEDTAG_COLOR_MARKED
    local mark_symbol=" "
    local opt=$4
    if $1; then  # if marked
        mark_symbol=$CURSEDTAG_SYMBOL_MARKED
        option_color=$CURSEDTAG_COLOR_MARKED
    fi
    if $2; then  # if selected
        option_color=$CURSEDTAG_COLOR_SELECTED
    fi
    printf '%s%s%s%s\e[0m\e[K' "$mark_color" "$mark_symbol" "$option_color" " $4 "
    if $3; then  # if dots should be added
        printf '…'
    fi
}

editor_prompt() {
    local append=$1
    local y=$2
    local x=$(($3 + 6))
    local input=$4
    local original=$input
    local field_width=$((max_columns - x + 1))
    local input_width=$((field_width - 1))

    local cursor=0
    local cursor_offset=0
    if $append; then
        cursor=${#input}
        cursor_offset=0
        if (( ${#input} > input_width )); then
            cursor=$input_width
            cursor_offset=$((${#input} - input_width))
        fi
    fi

    while true; do
        local position=$((cursor_offset + cursor))

        hide_cursor
        # erase input part of the field
        clear_line "$y" $((x - 1))

        move_cursor "$y" $x
        ln=$((input_width + 1))
        local dots=" "
        if (( cursor_offset + input_width < ${#input} )); then
            dots="…"
        fi
        printf -- '%s' "${input:$cursor_offset:$ln}${dots}"
        move_cursor "$y" $((x + cursor))
        show_cursor

        # catch multi-char special key sequences
        key=
        POSIXLY_CORRECT=1 read -srN1 key 2>&-
        POSIXLY_CORRECT=1 read -srN1 -t 0.0001 k1 2>&-
        POSIXLY_CORRECT=1 read -srN1 -t 0.0001 k2 2>&-
        POSIXLY_CORRECT=1 read -srN1 -t 0.0001 k3 2>&-
        key+=${k1}${k2}${k3}
        case "$key" in
            $'\e[D')
                # left arrow
                if (( cursor > 0 )); then
                    ((cursor--))
                else
                    ((cursor_offset > 0)) && \
                        ((cursor_offset--))
                fi
                ;;
            $'\e[C') # right arrow
                if ((cursor + cursor_offset < ${#input} )); then
                    if ((cursor >= input_width)); then
                        ((cursor_offset++))
                    else
                        ((cursor++))
                    fi

                fi
                ;;
            $'\ca'|$'\e[1~'|$'\e0H'|$'\e[H') # home
                cursor=0
                cursor_offset=0
                ;;
            $'\h'|$'\b') # ctrl+backspace
                cursor=0
                cursor_offset=0
                input=""
                ;;
            $'\ce'|$'\e[4~'|$'\e0F'|$'\e[F') # end
                cursor=${#input}
                cursor_offset=0
                if (( ${#input} > input_width )); then
                    cursor=$input_width
                    cursor_offset=$((${#input} - input_width))
                fi
                ;;
            $'\x7f'|$'\177') # backspace
                if (( position > 0)); then
                    r=$((position - 1))
                    input=${input:0:$r}${input:$position:${#input}}
                    if ((cursor > 0 )); then
                        ((cursor--))
                    else
                        ((cursor_offset > 0)) && \
                            ((cursor_offset--))
                    fi
                fi
                ;;
            $'\e[3~') # delete
                l=$((position + 1))
                input=${input:0:$position}${input:$l:${#input}}
                if (( cursor_offset > 0 )); then
                    cursor=$((cursor + 1))
                    cursor_offset=$((cursor_offset -1))
                fi
                ;;
            ''|$'\n')
                break
                ;;
            $'\x1b') # escape
                input=$original
                break
                ;;
            *)
                if ! [[ $key =~ [[:cntrl:]] ]]; then
                    input=${input:0:$position}$key${input:$position:${#input}}
                    if (( cursor < input_width )); then
                        cursor=$((cursor + ${#key}))
                    else
                        cursor_offset=$((cursor_offset + ${#key}))
                    fi
                fi
                ;;
        esac
    done

    editor_prompt_output=$input
}


start_selector() {
    local selected=1
    local select_all=0

    local marked=()

    local offset=0
    local page_step=$((LINES - 3))

    local idx=1
    if [[ -n $preselected ]]; then
        for opt; do
            if [[ $opt == "$preselected" ]]; then
                selected=$idx
                offset=$((idx - max_items + 1 ))
                offset=$((offset > 0 ? offset : 0))
                break
            fi
            ((idx++))
        done
    fi

    local clear_next=true
    while true; do
        if $resized || $clear_next; then
            hide_cursor
            clear_screen
            print_status_line "$(basename "$PWD")/"
            clear_next=false
            resized=false
        fi

        if $file_renamed; then
            file_renamed=false
            return
        fi

        idx=1
        for opt; do
            if ((idx > offset)) && ((idx < offset + max_items + 1)); then
                local is_selected=false
                local is_marked=false
                local is_too_long=false

                [[ $idx == "$selected" ]] && \
                    is_selected=true
                array_contains $idx "${marked[@]}" && \
                    is_marked=true

                local n=$((${#opt} + 2))
                if (( n >= max_columns )); then
                    is_too_long=true
                fi
                move_cursor $((1 - offset + idx))
                print_option "$is_marked" "$is_selected" "$is_too_long" "$opt"
            fi
            ((idx++))
        done

        # catch multi-char special key sequences
        key=
        POSIXLY_CORRECT=1 read -srN1 key 2>&-
        POSIXLY_CORRECT=1 read -srN1 -t 0.0001 k1 2>&-
        POSIXLY_CORRECT=1 read -srN1 -t 0.0001 k2 2>&-
        POSIXLY_CORRECT=1 read -srN1 -t 0.0001 k3 2>&-
        key+=${k1}${k2}${k3}
        case "$key" in
            k|$'\e[A')  # up arrow, k
                if ((selected > 1)); then
                    ((selected--))
                    if ((selected <= offset)); then
                        offset=$((offset > 1 ? offset - 1 : 0))
                    fi
                fi
                ;;
            j|$'\e[B')  # down arrow, j
                if ((selected < $#)); then
                    ((selected++))
                    if ((selected > offset + max_items)); then
                        ((offset++))
                    fi
                fi
                ;;
            h|$'\e[D')  # left arrow, h
                preselected="${PWD##*/}/"
                cd ..
                return
                ;;
            $'\cb'|$'\cu'|$'\e[5~')  # page up, ctrl+b, ctrl+u
                if ((selected - page_step > 1)); then
                    ((selected-=page_step))
                    if ((selected <= offset)); then
                        offset=$((offset - page_step > 0 ? offset - page_step : 0))
                    fi
                else
                    selected=1
                    offset=0
                fi
                ;;
            $'\cf'|$'\cd'|$'\e[6~')  # page down, ctrl+f, ctrl+d
                if ((selected + page_step < $#)); then
                    ((selected+=page_step))
                    if ((selected > offset + max_items - 1)); then
                        ((offset=selected - max_items))
                    fi
                else
                    selected=$#
                    ((offset=$# - max_items))
                    offset=$((offset > 0 ? offset : 0))
                fi
                ;;
            g|$'\e[1~'|$'\e0H'|$'\e[H')  # home
                selected=1
                offset=0
                ;;
            G|$'\e[4~'|$'\e0F'|$'\e[F')  # end
                selected=$#
                ((offset=$# - max_items))
                offset=$((offset > 0 ? offset : 0))
                ;;
            a|A|$'\ca'|$'\x01') # a, A, ctrl-a
                ((select_all ^= 1))
                marked=()
                if ((select_all == 1)); then
                    for ((i=1; i<idx; i++)); do
                        if [[ ${!i} != */ ]]; then
                            marked+=($i)
                        fi
                    done
                fi
                ;;
            y)  # yank
                yanked=${!selected}
                if [[ -n $CURSEDTAG_COMMAND_YANK ]]; then
                    echo -n $yanked | eval "$CURSEDTAG_COMMAND_YANK"
                fi
                ;;
            ' '|$'\x09')  # space, tab
                if [[ ${!selected} != */ ]]; then
                    local found=false
                    for i in "${!marked[@]}"; do
                        if [[ ${marked[i]} == "$selected" ]]; then
                            found=true
                            unset 'marked[i]'
                        fi
                    done
                    if ! $found; then
                        marked+=( $selected )
                    fi
                fi
                ;;
            e|l|$'\n'|$'\e[C') # enter, right arrow
                if [[ -n ${!selected} ]]; then
                    if [[ ${!selected} == */ ]]; then
                        cd "${!selected}" && return
                    else
                        local marked_strings=()
                        for m in "${marked[@]}"; do
                            (( m != selected )) && marked_strings+=("${!m}")
                        done
                        start_editor "${!selected}" "${marked_strings[@]}"
                        clear_next=true
                    fi
                fi
                ;;
            r)
                local marked_strings=()
                if [[ ${!selected} != */ ]]; then
                    marked_strings+=("${!selected}")
                fi
                for m in "${marked[@]}"; do
                    (( m != selected )) && marked_strings+=("${!m}")
                done
                if (( ${#marked_strings} > 0 )); then
                    start_scanner true "$#" "${marked_strings[@]}"
                    clear_next=true
                fi
                ;;
            f)
                local marked_strings=()
                if [[ ${!selected} != */ ]]; then
                    marked_strings+=("${!selected}")
                fi
                for m in "${marked[@]}"; do
                    (( m != selected )) && marked_strings+=("${!m}")
                done
                if (( ${#marked_strings} > 0 )); then
                    start_scanner false "$#" "${marked_strings[@]}"
                    clear_next=true
                fi
                clear_next=true
                ;;
            q|$'\x1b')
                clean_exit 0
                ;;
        esac
    done
}

bulk_rename() {
    local template=$1; shift
    local number_of_files=$1; shift
    for opt; do
        local extension="${opt##*.}"
        local newname=$template

        # read data
        data=()
        read_data "$opt"
        declare -A fields=()
        for field in "${!data[@]}"; do
            if [[ -v "specifiers[$field]" ]]; then
                local specifier=${specifiers[$field]}
                if ! [[ -v "fields[$specifier]" ]]; then
                    fields[$specifier]=${data[$field]}
                fi
            fi
        done
        # work-around for mid3v2's lack of tracktotal field
        if [[ $extension == "mp3" ]] && ! [[ -v "fields['l']" ]]; then
            local track="${fields['n']}"
            local x=$(strindex "$track" "/")
            if (( x > 0 )); then
                fields['n']=${track%\/*}
                fields['l']=${track##*\/}
            fi
        fi
        # align track numbers to the same width.
        # parse explicitely specified width (%3n -> 00n)
        if [[ $newname =~ %([1-9])n ]]; then
            local number_width=${BASH_REMATCH[1]}
            newname=${template//%[1-9]n/%n}
            fields['n']=$(zero_pad "${fields['n']}" "$number_width")
        else
            fields['n']=$(zero_pad "${fields['n']}" "${#number_of_files}")
        fi

        # replace specifiers with data
        for s in "${specifiers[@]}"; do
            if [[ $newname =~ %${s} ]]; then
                local substitution=${fields[$s]//\//_}
                newname=${newname//%${s}/${substitution}}
            fi
        done

        printf '%s\n' "$opt"
        printf ' -> %s.%s : ' "$newname" "$extension"
        newname=${newname/#~/$HOME}  # tilde expansion
        if [[ -z "${newname// }" ]]; then
            printf '%s empty file name. \e[0m\n' "$CURSEDTAG_COLOR_ERROR"
        elif [[ $opt == "$newname.$extension" ]]; then
            printf 'unchanged.\n'
        elif [[ -f "$newname.$extension" ]]; then
            printf '%s file exists. \e[0m\n' "$CURSEDTAG_COLOR_ERROR"
        else
            mkdir -p -- "$(dirname "$newname")"
            if ! mv -n -- "$opt" "$newname.$extension" 2>&-; then
                printf '%s could not rename. \e[0m\n' \
                    "$CURSEDTAG_COLOR_ERROR"
            else
                printf '%s renamed. \e[0m\n' "$CURSEDTAG_COLOR_SUCCESS"
                preselected=$newname.$extension
                file_renamed=true
            fi
        fi
        printf '\n'
    done
}

fill_tags() {
    local input=$1; shift
    for opt; do
        local regexp="$(echo "$input" | \
                sed -e 's,/,\\/,g ; s,|,\\|,g' \
                -e 's/(/\\(/g ; s/)/\\)/g ; s/\[/\\[/g ; s/\]/\\]/g')"
        local order_of_specifiers=()
        for tag in "${!specifiers[@]}"; do
            local specifier=${specifiers[$tag]}
            if [[ $input =~ .*%${specifier}.* ]]; then
                local x=$(strindex "$input" "%${specifier}")
                regexp=${regexp//%${specifier}/\(.*?\)}
                if (( x >= 0 )); then
                    order_of_specifiers[$x]=$tag
                fi
            fi
        done

        local idx=1
        local replacement=()
        for s in "${order_of_specifiers[@]}"; do
            replacement+=("${s}=\\${idx}")
            ((idx++))
        done
        local parent_name=""
        local parent=""
        local filename="${opt%.*}"
        local slashes="${regexp//[^\/]}"
        local slashes_count=${#slashes}
        ((slashes_count > 0 )) && for ((i=1; i<=slashes_count; i++)); do
            parent_name="$(basename "${parent:-$PWD}")"
            if ! [[ $parent_name == "/" ]]; then
                filename=${parent_name}/${filename}
            else
                filename=/$filename
                break
            fi
            parent=$(dirname "${parent:-$PWD}")
        done
        if (( ${#replacement[@]} )); then
            local replacement_str=$(join_by "^" "${replacement[@]}")
            output=$(echo "$filename" | \
                perl -ne "print if s|^${regexp}$|${replacement_str}|")
            if [[ -n "$output" ]]; then
                printf '%s\n' "$opt"
                while IFS= read -r -d '^' line; do
                    local field=${line%=*}
                    local value=${line##*=}
                    local tag=$(arrayindex "$field" specifiers)
                    set_field "$field" "$value" "$opt"
                    printf '    %s[%s]\e[0m = %s\n' "$CURSEDTAG_COLOR_OPTION" \
                        "$field" "$value"
                done <<< "${output}^"
                printf '\n'
            fi
        fi
    done
}

start_scanner() {
    local rename_mode=$1; shift
    local number_of_files=$1; shift
    local number_width=${#number_of_files}
    local input=${CURSEDTAG_DEFAULT_TEMPLATE}
    local cursor=${#input}
    local preview=""

    # read data
    data=()
    data_state=()
    read_data "$1"
    declare -A fields=()
    for field in "${!data[@]}"; do
        if [[ -v "specifiers[$field]" ]]; then
            local specifier=${specifiers[$field]}
            if ! [[ -v "fields[$specifier]" ]]; then
                fields[$specifier]=${data[$field]}
            fi
        fi
    done
    # work-around for mid3v2's lack of tracktotal field
    if ! [[ -v "fields['l']" ]]; then
        local track="${fields['n']}"
        local x=$(strindex "$track" "/")
        if (( x > 0 )); then
            fields['n']=${track%\/*}
            fields['l']=${track##*\/}
        fi
    fi
    # align track numbers to the same width
    fields['n']=$(zero_pad "${fields['n']}" "$number_width")

    local legend=()
    for s in "${!specifiers[@]}"; do
        if ! $rename_mode && [[ $s =~ ^_ ]]; then
            continue
        fi
        legend+=("%${specifiers[$s]}: ${fieldmapping[$s]}")
    done
    IFS=$'\n' sorted_legend=($(sort <<< "${legend[*]}"))

    hide_cursor
    clear_screen
    print_status_line "$@"
    move_cursor 5
    printf 'Legend\n'
    for n in "${sorted_legend[@]}"; do
        printf '  %s\n' "$n"
    done

    while true; do
        if $rename_mode; then
            preview=$input
            if [[ $preview =~ %([1-9])n ]]; then
                number_width=${BASH_REMATCH[1]}
                preview=${preview//%[1-9]n/%n}
                fields['n']=$(zero_pad "${fields['n']}" "$number_width")
            else
                # we need to reset, if it's deleted
                number_width=${#number_of_files}
            fi
            # replace specifiers with data
            for s in "${specifiers[@]}"; do
                if [[ $preview =~ %${s} ]]; then
                    local substitution=${fields[$s]//\//_}
                    if [[ -z $substitution ]]; then
                        substitution="[…]"
                    fi
                    preview=${preview//%${s}/${substitution}}
                fi
            done
        else
            # parse filename according to template
            preview=""
            local regexp="$(echo "$input" | \
                    sed -e 's,/,\\/,g ; s,|,\\|,g' \
                    -e 's/(/\\(/g ; s/)/\\)/g ; s/\[/\\[/g ; s/\]/\\]/g')"
            local order=()
            for s in "${!specifiers[@]}"; do
                if [[ ! $s =~ ^_ ]] && [[ $input =~ %${specifiers[$s]} ]]; then
                    local x=$(strindex "$input" "%${specifiers[$s]}")
                    regexp=${regexp//%${specifiers[$s]}/\(.*?\)}
                    if (( x >= 0 )); then
                        order[$x]=${specifiers[$s]}
                    fi
                fi
            done

            local idx=1
            local replacement=()
            for s in "${order[@]}"; do
                replacement+=("%${s}=\\${idx}")
                ((idx++))
            done
            local parent_name=""
            local parent=""
            local filename="${1%.*}"
            local slashes="${regexp//[^\/]}"
            local slashes_count=${#slashes}
            if ((slashes_count > 0 )); then
                for ((i=1; i<=slashes_count; i++)); do
                    parent_name="$(basename "${parent:-$PWD}")"
                    if ! [[ $parent_name == "/" ]]; then
                        filename=${parent_name}/${filename}
                    else
                        filename=/$filename
                        break
                    fi
                    parent=$(dirname "${parent:-$PWD}")
                done
                print_status_line "$filename"
            fi
            if (( ${#replacement[@]} )); then
                local replacement_str=$(join_by " " "${replacement[@]}")
                output=$(echo "$filename" | \
                    perl -ne "print if s|^${regexp}$|${replacement_str}|")
                [[ -n "$output" ]] && \
                    preview=$output
            fi
        fi

        # erase only lines that change to avoid too much clear_screen
        hide_cursor
        clear_line 3
        clear_line 4
        move_cursor 2
        printf ' > %s\e[K\n' "$input"
        # "two lines should be enough for everyone"
        printf '\e[32m%s\e[0m\e[K\n' "${preview::$max_columns}"
        printf '\e[32m%s\e[0m\e[K' "${preview:$((max_columns - 1))}"
        # jump back to prompt
        move_cursor 2 $((4 + cursor))
        show_cursor

        # catch multi-char special key sequences
        key=
        POSIXLY_CORRECT=1 read -srN1 key 2>&-
        POSIXLY_CORRECT=1 read -srN1 -t 0.0001 k1 2>&-
        POSIXLY_CORRECT=1 read -srN1 -t 0.0001 k2 2>&-
        POSIXLY_CORRECT=1 read -srN1 -t 0.0001 k3 2>&-
        key+=${k1}${k2}${k3}
        case "$key" in
            $'\e[D')
                # left arrow
                ((cursor > 0 )) && ((cursor--))
                ;;
            $'\e[C') # right arrow
                ((cursor < ${#input} )) && ((cursor++))
                ;;
            $'\ca'|$'\e[1~'|$'\e0H'|$'\e[H') # home
                cursor=0
                ;;
            $'\ce'|$'\e[4~'|$'\e0F'|$'\e[F') # end
                cursor=${#input}
                ;;
            $'\x7f'|$'\177') # backspace
                if (( cursor > 0)); then
                    r=$((cursor - 1))
                    input=${input:0:$r}${input:$cursor:${#input}}
                    cursor=$r
                fi
                ;;
            $'\h'|$'\b') # ctrl+backspace
                input=
                cursor=0
                ;;
            $'\e[3~') # delete
                l=$((cursor + 1))
                input=${input:0:$cursor}${input:$l:${#input}}
                ;;
            $'\n')
                break
                ;;
            $'\x1b') # escape
                return
                ;;
            *)
                if ! [[ $key =~ [[:cntrl:]] ]]; then
                    input=${input:0:$cursor}$key${input:$cursor:${#input}}
                    cursor=$((cursor + ${#key}))
                fi
                ;;
        esac
    done

    # redraw the screen without legend
    clear_screen
    print_status_line "$@"
    move_cursor 2
    printf ' > %s\n' "$input"
    printf '\e[32m%s\e[0m\e[K\n' "${preview::$max_columns}"
    printf '\e[32m%s\e[0m\e[K\n' "${preview:$((max_columns - 1))}"

    if $rename_mode; then
        bulk_rename "$input" "$((10**(number_width-1)))" "$@"
    else
        fill_tags "$input" "$@"
    fi
    wait_for_key
}

read_data() {
    data['_filename']="${1%.*}"
    read_data_mid3v2 "$1"
    read_data_metaflac "$1"
    read_data_vorbiscomment "$1"
}

read_data_mid3v2() {
    local extension="${1##*.}"
    if [[ $extension == "mp3" ]]; then
        data['_size']=$(du -h -- "$1" | awk '{print $1}')
        data['_bitrate']=$(sox --i -B -- "$1" 2>&-)
        local secs=$(sox --i -D -- "$1" 2>&-)
        secs="${secs%%.*}"
        data['_length']=$(convert_time "$secs")
        local tyer

        while read -r line; do
            local tag=$(echo "$line" | grep -ao "^....")
            local value=$(echo "$line" | sed "s/[^ ]*=\(.*\)$/\1/")
            if [[ -v "mid3v2_mapping[$tag]" ]]; then
                local tagname="${mid3v2_mapping[$tag]}"
                if ! [[ -v "data[$tagname]" ]]; then
                    data[$tagname]=$value
                    data_state[$tagname]=$value
                fi
            fi
            if [[ "$tag" == "TYER" ]]; then
                tyer=$value
            fi
        done <<< "$(mid3v2 -q -- "$1" | grep -a "^....=" | tr '\0' '=')"

        # use date from TYER, but only when TDRC is not set
        if [[ -n "$tyer" ]] && ! [[ -v "data[date]" ]]; then
            data['date']=$tyer
            data_state['date']=$tyer
        fi

        # split TRCK field into track and tracktotal
        if [[ "${data['track']}" == */* ]]; then
            local value=${data['track']}
            data['track']=${value%%/*}
            data['tracktotal']=${value##*/}
            data_state['track']=${data['track']}
            data_state['tracktotal']=${data['tracktotal']}
        fi
    fi
}

read_data_metaflac() {
    local extension="${1##*.}"
    if [[ $extension == "flac" ]]; then
        data['_size']=$(du -h -- "$1" | awk '{print $1}')
        data['_bitrate']=$(sox --i -B -- "$1" 2>&-)
        local secs=$(sox --i -D -- "$1" 2>&-)
        secs="${secs%%.*}"
        data['_length']=$(convert_time "$secs")

        while read -r line; do
            tag=$(echo "$line" | grep -ao "^[A-Z]*")
            value=${line//[A-Z]*=/}
            if [[ -v "vorbis_mapping[$tag]" ]]; then
                local tagname="${vorbis_mapping[$tag]}"
                if ! [[ -v "data[$tagname]" ]]; then
                    data[$tagname]=$value
                    data_state[$tagname]=$value
                fi
            fi
        done <<< "$(metaflac --list --except-block-type=PICTURE \
            -- "$1" | grep -ao "[A-Z]*=.*")"
    fi
}

read_data_vorbiscomment() {
    local extension="${1##*.}"
    if [[ $extension == "ogg" ]]; then
        data['_size']=$(du -h -- "$1" | awk '{print $1}')
        data['_bitrate']=$(sox --i -B -- "$1" 2>&-)
        local secs=$(sox --i -D -- "$1" 2>&-)
        secs="${secs%%.*}"
        data['_length']=$(convert_time "$secs")

        while read -r line; do
            tag=$(echo "$line" | grep -ao "^[A-Z]*")
            value=${line//[A-Z]*=/}
            if [[ -v "vorbis_mapping[$tag]" ]]; then
                local tagname="${vorbis_mapping[$tag]}"
                if ! [[ -v "data[$tagname]" ]]; then
                    data[$tagname]=$value
                    data_state[$tagname]=$value
                fi
            fi
        done <<< "$(vorbiscomment -l -- "$1" | grep -ao "[A-Z]*=.*")"
    fi
}

set_field() {
    set_field_mid3v2 "$@"
    set_field_metaflac "$@"
    set_field_vorbiscomment "$@"
}

set_field_mid3v2() {
    local field=$1; shift
    local value=$1; shift

    local is_track=false
    local is_tracktotal=false
    if [[ $field == "tracktotal" ]]; then
        is_tracktotal=true
    fi
    if [[ $field == "track" ]]; then
        is_track=true
    fi

    local tag=$(arrayindex "$field" mid3v2_mapping)
    local options=("--delete-frames" "$tag")
    if [[ -n "$value" ]]; then
        options+=("--$tag" "$value")
    fi

    local files=()
    for opt; do
        local extension="${opt##*.}"
        if [[ $extension == "mp3" ]]; then
            if $is_tracktotal; then
                local track_field=$(mid3v2 -q -- "$opt" | sed -n 's/^TRCK=//p')
                local track="${track_field%%/*}"
                local new_value="${track}${value:+/}${value}"
                if [[ -n "$new_value" ]]; then
                    mid3v2 --TRCK "$new_value" -- "$opt"
                else
                    mid3v2 --delete-frames TRCK -- "$opt"
                fi
            elif $is_track; then
                local track_field=$(mid3v2 -q -- "$opt" | sed -n 's/^TRCK=//p')
                local tracktotal="${track_field##*/}"
                local new_value="${value}${tracktotal:+/}${tracktotal}"
                if [[ -n "$new_value" ]]; then
                    mid3v2 --TRCK "$new_value" -- "$opt"
                else
                    mid3v2 --delete-frames TRCK -- "$opt"
                fi
            else
                files+=("$opt")
            fi

        fi
    done
    if (( ${#options[@]} )) && (( ${#files[@]} )); then
        mid3v2 "${options[@]}" -- "${files[@]}"
    fi
}

set_field_metaflac() {
    local field=$1; shift
    local value=$1; shift

    local tag=$(arrayindex "$field" vorbis_mapping)
    local options=("--remove-tag" "$tag")
    if [[ -n "$value" ]]; then
        options+=("--set-tag" "$tag=$value")
    fi

    local files=()
    for opt; do
        local extension="${opt##*.}"
        if [[ $extension == "flac" ]]; then
            files+=("$opt")
        fi
    done
    if (( ${#options[@]} )) && (( ${#files[@]} )); then
        metaflac "${options[@]}" -- "${files[@]}"
    fi
}

set_field_vorbiscomment() {
    local field=$1; shift
    local value=$1; shift

    local tag=$(arrayindex "$field" vorbis_mapping)
    options=("--tag" "$tag=$value")

    local files=()
    for opt; do
        local extension="${opt##*.}"
        if [[ $extension == "ogg" ]]; then
            {
                vorbiscomment "$opt" | grep -v "^$tag"
                echo "$tag=$value"
            } | vorbiscomment -c - -w -- "$opt"
        fi
    done
}

start_editor() {
    local selected=1
    local offset=0
    local idx=1
    local extension="${1##*.}"

    local page_step=$((LINES - 3))
    local list_size=${#fieldorder[@]}

    # read data
    data=()
    data_state=()
    read_data "$1"

    # get widest field name to create nice grid
    local max_field_length=0
    for s in "${fieldorder[@]}"; do
        if [[ ${#fieldmapping[$s]} -gt $max_field_length ]]; then
            local max_field_length=${#fieldmapping[$s]}
        fi
    done
    ((max_field_length++))

    local number_prefix=1
    local clear_next=true
    while true; do
        local field_index=$((selected - 1))
        local field=${fieldorder[$field_index]}

        # clear screen if the offset changed
        if $resized || $clear_next; then
            hide_cursor
            clear_screen
            print_status_line "$(basename "$@")"
            move_cursor 2
            clear_next=false
            resized=false
            printf 'bitrate: %s%-4s\e[0m  ' \
                "$CURSEDTAG_COLOR_OPTION" "${data[_bitrate]}"
            printf 'file size: %s%-4s\e[0m  ' \
                "$CURSEDTAG_COLOR_OPTION" "${data[_size]}"
            printf 'length: %s%s\e[0m\n' \
                "$CURSEDTAG_COLOR_OPTION" "${data[_length]}"
        fi

        # print options
        idx=1
        for s in "${fieldorder[@]}"; do
            if ((idx > offset)) && ((idx < offset + max_items)); then
                local fieldname=${fieldmapping[$s]}
                local is_selected=false
                local is_unsaved=false
                local is_too_long=false

                [[ $idx == "$selected" ]] && \
                    is_selected=true
                if ! [[ ${data[$s]} == "${data_state[$s]}" ]]; then
                    is_unsaved=true
                fi

                move_cursor $((2 - offset + idx))  # starting at 3nd row
                printf ' %-*s %s:' "$max_field_length" "$fieldname"

                local n=$((${#data_state[$s]} + max_field_length + 5))
                if (( n >= max_columns )); then
                    is_too_long=true
                fi
                print_option "$is_unsaved" "$is_selected" "$is_too_long" "${data_state[$s]}"
            fi
            ((idx++))
        done

        # catch multi-char special key sequences
        key=
        POSIXLY_CORRECT=1 read -srN1 key 2>&-
        POSIXLY_CORRECT=1 read -srN1 -t 0.0001 k1 2>&-
        POSIXLY_CORRECT=1 read -srN1 -t 0.0001 k2 2>&-
        POSIXLY_CORRECT=1 read -srN1 -t 0.0001 k3 2>&-
        key+=${k1}${k2}${k3}
        case "$key" in
            [2-9])
                number_prefix=$key
                ;;
            k|$'\e[A')  # up
                if ((selected - number_prefix > 1)); then
                    ((selected-=number_prefix))
                    if ((selected < offset + 1)); then
                        offset=$((offset - number_prefix > 0 ? offset - number_prefix : 0))
                    fi
                else
                    selected=1
                    offset=0
                fi
                number_prefix=1
                ;;
            j|$'\e[B')  # down
                if ((selected + number_prefix < list_size)); then
                    ((selected+=number_prefix))
                    if ((selected > offset + max_items - 1)); then
                        ((offset=selected - max_items + 1))
                    fi
                else
                    selected=$list_size
                    ((offset=list_size - max_items + 1))
                    offset=$((offset > 0 ? offset : 0))
                fi
                number_prefix=1
                ;;
            $'\cb'|$'\e[5~')  # page up
                if ((selected - page_step > 1)); then
                    ((selected-=page_step))
                    if ((selected < offset + 1)); then
                        offset=$((offset - page_step > 0 ? offset - page_step : 0))
                    fi
                else
                    selected=1
                    offset=0
                fi
                ;;
            $'\cf'|$'\e[6~')  # page down
                if ((selected + page_step < list_size)); then
                    ((selected+=page_step))
                    if ((selected > offset + max_items - 1)); then
                        ((offset=selected - max_items + 1))
                    fi
                else
                    selected=$list_size
                    ((offset=list_size - max_items + 1))
                    offset=$((offset > 0 ? offset : 0))
                fi
                ;;
            g|$'\e[1~'|$'\e0H'|$'\e[H')  # home
                selected=1
                offset=0
                ;;
            G|$'\e[4~'|$'\e0F'|$'\e[F')  # end
                selected=$list_size
                ((offset=list_size - max_items + 1))
                offset=$((offset > 0 ? offset : 0))
                ;;
            i)  # edit (cursor at start)
                editor_prompt_output=""
                editor_prompt false $((selected - offset + 2)) \
                    $max_field_length "${data_state[$field]}"
                data_state[$field]=$editor_prompt_output
                hide_cursor
                clear_line $((selected - offset + 2))
                ;;
            a|$'\n') # edit (cursor at end)
                editor_prompt_output=""
                editor_prompt true $((selected - offset + 2)) \
                    ${max_field_length} "${data_state[$field]}"
                data_state[$field]=$editor_prompt_output
                hide_cursor
                clear_line $((selected - offset + 2))
                ;;
            y)  # yank
                yanked=${data_state[$field]}
                if [[ -n $CURSEDTAG_COMMAND_YANK ]]; then
                    echo -n $yanked | eval "$CURSEDTAG_COMMAND_YANK"
                fi
                ;;
            p)  # paste
                if [[ -v yanked ]]; then
                    data_state[$field]=$yanked
                    clear_line $((selected - offset + 2))
                fi
                ;;
            x|d) # erase
                yanked=${data_state[$field]}
                data_state[$field]=""
                clear_line $((selected - offset + 2))
                ;;
            u)  # undo
                data_state[$field]=${data[$field]}
                clear_line $((selected - offset + 2))
                ;;
            S|W) # apply field to all files
                clear_next=true
                clear_screen
                print_status_line "$@"
                move_cursor 3 0
                data[$field]=${data_state[$field]}
                set_field "$field" "${data_state[$field]}" "$@"
                printf '%s[%s]\e[0m = %s\n' "$CURSEDTAG_COLOR_OPTION" \
                    "$field" "${data_state[$field]}"
                printf '    %s\n' "${@}"
                print
                wait_for_key
                ;;
            s|w) # save
                clear_next=true
                clear_screen
                print_status_line "$@"
                move_cursor 3 0
                printf '%s\n' "$1"
                for n in "${!data_state[@]}"; do
                    if ! [[ "${data_state[$n]}" == "${data[$n]}" ]]; then
                        data[$n]=${data_state[$n]}
                        set_field "$n" "${data_state[$n]}" "$1"
                        printf '    %s[%s]\e[0m = %s\n' \
                            "$CURSEDTAG_COLOR_OPTION" "$n" "${data[$n]}"
                    fi
                done
                wait_for_key
                ;;
            h|$'\e[D'|$'\x1b')  # back to selector
                return
                ;;
            q) # quit
                clean_exit 0
                ;;
        esac
    done
}

clean_exit() {
    reset_terminal
    show_cursor
    trap '' EXIT
    trap '' WINCH
    # shellcheck disable=SC2086
    exit $1
}

start() {
    local file=$1; shift
    local path=$file

    get_term_size
    setup_terminal
    trap 'get_term_size' WINCH
    trap 'reset_terminal' EXIT

    # needed for expansion in zero_pad function
    shopt -s extglob

    if [[ -z "$preselected" ]] && [[ -f "$file" ]]; then
        preselected=$(basename "$file")
        path=$(dirname "$file")
        start_editor "$file"
        clear
    fi

    builtin cd "$path"
    while true; do
        local audio_files=()
        local directories=()

        # directories
        while IFS=  read -r -d $'\0'; do
            directories+=("$(basename "$REPLY")/")
        done < <(find . -maxdepth 1 -type d -not -name '.*' -print0)

        # mp3 support check
        [[ -x "$(command -v mid3v2)" ]] && while IFS=  read -r -d $'\0'; do
            audio_files+=("$(basename "$REPLY")")
        done < <(find . -maxdepth 1 -type f -name "*.mp3" -print0)

        # flac support check
        [[ -x "$(command -v metaflac)" ]] && while IFS=  read -r -d $'\0'; do
            audio_files+=("$(basename "$REPLY")")
        done < <(find . -maxdepth 1 -type f -name "*.flac" -print0)

        # ogg support check
        [[ -x "$(command -v ogginfo)" ]] && while IFS=  read -r -d $'\0'; do
            audio_files+=("$(basename "$REPLY")")
        done < <(find . -maxdepth 1 -type f -name "*.ogg" -print0)

        IFS=$'\n' sorted_dirs=($(sort <<< "${directories[*]}"))
        IFS=$'\n' sorted=($(sort <<< "${audio_files[*]}"))
        start_selector "${sorted_dirs[@]}" "${sorted[@]}"
    done
}

# main
arg=${1:-"."}
if [[ -n "$arg" ]]; then
    if [[ -e "$arg" ]]; then
        start "$arg"
    else
        echo >&2 "File not found."
        exit 1
    fi
fi
