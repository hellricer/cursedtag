#!/usr/bin/env bash
#
# cursedtag - a console audio tag editor.

# read configuration file
if [ -f "${XDG_CONFIG_HOME:-$HOME/.config}/cursedtag/rc" ]; then
    . "${XDG_CONFIG_HOME:-$HOME/.config}/cursedtag/rc"
fi

# default configuration. You can just paste these lines
# to the configuration file and customize.
: ${CURSEDTAG_COLOR_ERROR:=$'\e[91m'}
: ${CURSEDTAG_COLOR_OPTION:=$'\e[34m'}
: ${CURSEDTAG_COLOR_STATUS:=$'\e[33m'}
: ${CURSEDTAG_COLOR_MARKED:=$'\e[32m'}
: ${CURSEDTAG_COLOR_SUCCESS:=$'\e[32m'}
: ${CURSEDTAG_COLOR_SELECTED:=$'\e[7m'}
: ${CURSEDTAG_DEFAULT_TEMPLATE:=}
: ${CURSEDTAG_FIELDS:="title artist albumartist album
                date track tracktotal genre comment composer performer"}


# mapping of field ids to human readable labels
declare -A fieldmapping
fieldmapping=(
    [title]="Title"
    [artist]="Artist"
    [albumartist]="Album artist"
    [album]="Album"
    [date]="Year"
    [track]="Track"
    [genre]="Genre"
    [comment]="Comment"
    [composer]="Composer"
    [performer]="Performer"
    [tracktotal]="Number of tracks"
)

# short specifiers used in scanner mode
declare -A specifiers
specifiers=(
    [title]=t
    [artist]=a
    [albumartist]=z
    [album]=b
    [date]=y
    [track]=n
    [genre]=g
    [comment]=c
    [composer]=p
    [performer]=P
    [tracktotal]=l
)

# map fields to IDs used my mid3v2
declare -A mid3v2_mapping
mid3v2_mapping=(
    [TIT2]=title
    [TPE1]=artist
    [TPE2]=albumartist
    [TALB]=album
    [TDRC]=date
    [TRCK]=track
    [TCON]=genre
    [COMM]=comment
    [TCOM]=composer
    [TPE3]=performer
    #[...]=tracktotal
)

# map fields to IDs used my metaflac & vorbiscomment
declare -A vorbis_mapping
vorbis_mapping=(
    [TITLE]=title
    [ARTIST]=artist
    [ALBUMARTIST]=albumartist
    [ALBUM]=album
    [DATE]=date
    [TRACKNUMBER]=track
    [GENRE]=genre
    [DESCRIPTION]=comment
    [COMPOSER]=composer
    [PERFORMER]=performer
    [TRACKTOTAL]=tracktotal
)

declare -a fieldorder
fieldorder=(${CURSEDTAG_FIELDS//:/ })

# global variables
declare -A data
declare -A data_state

get_term_size() {
    # Get terminal size ('stty' is POSIX and always available).
    # This can't be done reliably across all bash versions in pure bash.
    read -r ROWS COLS < <(stty size)

    # Max items that fit in the scroll area (leaving first & last row empty)
    max_items=$((${ROWS%% *} - 2))
}

setup_terminal() {
    # Setup the terminal for the TUI.
    # '\e[?1049h': Use alternative screen buffer.
    # '\e[?7l':    Disable line wrapping.
    # '\e[?25l':   Hide the cursor.
    # '\e[2J':     Clear the screen.
    # '\e[1;Nr':   Limit scrolling to scrolling area.
    #              Also sets cursor to (0,0).
    printf '\e[?1049h\e[?7l\e[?25l\e[2J\e[1;%sr' "$max_items"

    # Hide echoing of user input
    stty -echo
}

reset_terminal() {
    # Reset the terminal to a useable state (undo all changes).
    # '\e[?7h':   Re-enable line wrapping.
    # '\e[?25h':  Unhide the cursor.
    # '\e[2J':    Clear the terminal.
    # '\e[;r':    Set the scroll region to its default value.
    #             Also sets cursor to (0,0).
    # '\e[?1049l: Restore main screen buffer.
    printf '\e[?7h\e[?25h\e[2J\e[;r\e[?1049l'

    # Show user input.
    stty echo
}

clear_screen() {
    printf '\e[2J'
}

clear_line() {
    printf '\e[%s;%sH\e[0K' "$1" "${2:0}"
}

move_cursor() {
    printf '\e[%s;%sH' "$1" "${2:0}"
}

show_cursor() {
    printf '\e[?25h'
}

hide_cursor() {
    printf '\e[?25l'
}

array_contains() {
    local seeking=$1; shift
    for element; do
        if [[ $element == $seeking ]]; then
            return
        fi
    done
    false
}

basename() {
    : "${1%/}"
    printf '%s\n' "${_##*/}"
}

dirname() {
    [[ $1 = */* ]] && printf '%s\n' "${1%/*}" || printf '.\n'
}

convert_time() {
    local h=$(($1 / 3600))
    local h_remain=$(($1 & 3600))
    local m=$((h_remain / 60))
    local s=$(($1 % 60))
    if (( h > 0 )); then
        printf '%02d:%02d:%02.0f\n' $h $m $s
    else
        printf '%02d:%02.0f\n' $m $s
    fi
}

strindex() {
    local x="${1%%$2*}"
    [[ "$x" = "$1" ]] && echo -1 || echo "${#x}"
}

arrayindex() {
    local field=$1
    local -n givenList=$2
    local tag=
    for i in "${!givenList[@]}"; do
        if [[ ${givenList[$i]} == $field ]]; then
            tag=$i
            break
        fi
    done
    echo $tag
}

join_by() {
    local IFS="$1"; shift; echo "$*";
}

ellipsis() {
    local i=$1
    local n=$((${#i} + $2))
    if [[ ${n} -ge $COLS ]]; then
        i=${i::$COLS}
        i="$i""…"
    fi
    printf -- '%s' "$i"
}

print_status_line() {
    local others=""
    local files=$(($# - 1))
    if [[ $# -gt 1 ]]; then
        others=" [and $files others]"
    fi
    move_cursor 0
    status="${1}${others}"
    short=$(ellipsis "$status" 0)
    printf '%s%s\e[0m\n' "$CURSEDTAG_COLOR_STATUS" "$short"
}

print_option() {
    local option_color=$CURSEDTAG_COLOR_OPTION
    local mark_color=$CURSEDTAG_COLOR_MARKED
    local mark_symbol=" "
    if $1; then  # if marked
        mark_symbol="*"
        option_color=$CURSEDTAG_COLOR_MARKED
    fi
    if $2; then  # if selected
        option_color=$CURSEDTAG_COLOR_SELECTED
    fi
    printf '%s%s%s%s\e[0m' $mark_color "$mark_symbol" $option_color "$3"
}

editor_prompt() {
    local append=$1
    local y=$2
    local x=$(($3 + 6))
    local input=$4
    local original=$input
    local field_width=$((COLS - x + 1))
    local input_width=$((field_width - 1))

    local cursor=0
    local cursor_offset=0
    if $append; then
        cursor=${#input}
        cursor_offset=0
        if (( ${#input} > input_width )); then
            cursor=$input_width
            cursor_offset=$((${#input} - input_width))
        fi
    fi

    while true; do
        local position=$((cursor_offset + cursor))

        hide_cursor
        # erase input part of the field
        clear_line $y $((x - 1))

        move_cursor $y $x
        ln=$((input_width + 1))
        local dots=" "
        if (( cursor_offset + input_width < ${#input} )); then
            dots="…"
        fi
        printf -- '%s' "${input:$cursor_offset:$ln}${dots}"
        move_cursor $y $((x + cursor))
        show_cursor

        # catch multi-char special key sequences
        read -sN1 key
        read -sN1 -t 0.0001 k1
        read -sN1 -t 0.0001 k2
        read -sN1 -t 0.0001 k3
        key+=${k1}${k2}${k3}
        case "$key" in
            $'\e[D')
                # left arrow
                if (( cursor > 0 )); then
                    ((cursor--))
                else
                    ((cursor_offset > 0)) && \
                        ((cursor_offset--))
                fi
                ;;
            $'\e[C') # right arrow
                if ((cursor + cursor_offset < ${#input} )); then
                    if ((cursor >= input_width)); then
                        ((cursor_offset++))
                    else
                        ((cursor++))
                    fi

                fi
                ;;
            $'\ca'|$'\e[1~'|$'\e0H'|$'\e[H') # home
                cursor=0
                cursor_offset=0
                ;;
            $'\h'|$'\b') # ctrl+backspace
                cursor=0
                cursor_offset=0
                input=""
                ;;
            $'\ce'|$'\e[4~'|$'\e0F'|$'\e[F') # end
                cursor=${#input}
                cursor_offset=0
                if (( ${#input} > input_width )); then
                    cursor=$input_width
                    cursor_offset=$((${#input} - input_width))
                fi
                ;;
            $'\x7f'|$'\177') # backspace
                if (( position > 0)); then
                    r=$((position - 1))
                    input=${input:0:$r}${input:$position:${#input}}
                    if ((cursor > 0 )); then
                        ((cursor--))
                    else
                        ((cursor_offset > 0)) && \
                            ((cursor_offset--))
                    fi
                fi
                ;;
            $'\e[3~') # delete
                l=$((position + 1))
                input=${input:0:$position}${input:$l:${#input}}
                if (( cursor_offset > 0 )); then
                    cursor=$((cursor + 1))
                    cursor_offset=$((cursor_offset -1))
                fi
                ;;
            ''|$'\n')
                break
                ;;
            $'\x1b') # escape
                input=$original
                break
                ;;
            *)
                if ! [[ $key =~ [[:cntrl:]] ]]; then
                    input=${input:0:$position}$key${input:$position:${#input}}
                    if (( cursor < input_width )); then
                        cursor=$((cursor + ${#key}))
                    else
                        cursor_offset=$((cursor_offset + ${#key}))
                    fi
                fi
                ;;
        esac
    done

    editor_prompt_output=$input
}


start_selector() {
    local selected=1
    local select_all=0

    local marked=()

    local offset=1
    local lastoffset=0
    local page_step=$((ROWS - 3))

    local idx=1
    if [[ -n $preselected ]]; then
        for opt; do
            if [[ $opt == $preselected ]]; then
                selected=$idx
                offset=$((idx - max_items + 1 ))
                offset=$((offset > 1 ? offset : 1 ))
                break
            fi
            ((idx++))
        done
    fi

    local clear_next=false
    while true; do
        if $clear_next || [[ $lastoffset != $offset ]]; then
            hide_cursor
            clear_screen
            print_status_line "${PWD##*/}"
            clear_next=false
        fi

        if $file_renamed; then
            file_renamed=false
            return
        fi

        idx=1
        lastoffset=$offset
        for opt; do
            if ((idx >= offset)) && ((idx < offset + max_items)); then
                move_cursor $((2 - offset + idx))  # starting at 2nd row
                local is_selected=false
                local is_marked=false
                [[ $idx == $selected ]] && \
                    is_selected=true
                array_contains $idx "${marked[@]}" && \
                    is_marked=true
                local dots=$(ellipsis " $opt " 2)
                print_option "$is_marked" "$is_selected" "$dots"
            fi
            ((idx++))
        done

        # catch multi-char special key sequences
        read -sN1 key
        read -sN1 -t 0.0001 k1
        read -sN1 -t 0.0001 k2
        read -sN1 -t 0.0001 k3
        key+=${k1}${k2}${k3}
        case "$key" in
            k|$'\e[A')  # up arrow
                if (( selected > 1 )); then
                    ((selected--))
                    if (( selected < offset )); then
                        ((offset--))
                    fi
                fi
                ;;
            j|$'\e[B')  # down arrow
                if (( selected < $# )); then
                    ((selected++))
                    if (( selected > offset + max_items - 1 )); then
                        ((offset++))
                    fi
                fi
                ;;
            $'\cb'|$'\e[5~')  # ctrl+b, page up
                if (( selected - page_step > 1 )); then
                    ((selected-=page_step))
                    if (( selected < offset )); then
                        ((offset-=page_step))
                    fi
                else
                    selected=1
                    offset=1
                fi
                ;;
            $'\cf'|$'\e[6~')  # ctrl+f, page down
                if (( selected + page_step < $# )); then
                    ((selected+=page_step))
                    if (( selected > offset + max_items - 1 )); then
                        ((offset+=page_step))
                    fi
                else
                    selected=$#
                    ((offset=$# - max_items + 1))
                    offset=$((offset > 1 ? offset : 1))
                fi
                ;;
            g|$'\e[1~'|$'\e0H'|$'\e[H')  # home
                selected=1
                offset=1
                ;;
            G|$'\e[4~'|$'\e0F'|$'\e[F')  # end
                selected=$#
                ((offset=$# - max_items + 1))
                offset=$((offset > 1 ? offset : 1))
                ;;
            a|A|$'\ca'|$'\x01')  # ctrl+a
                ((select_all ^= 1))
                marked=()
                if ((select_all == 1)); then
                    for ((i=1; i<idx; i++)); do
                        marked+=($i)
                    done
                fi
                ;;
            ' '|$'\x09')  # tab
                local found=false
                for i in "${!marked[@]}"; do
                    if [[ ${marked[i]} == $selected ]]; then
                        found=true
                        unset 'marked[i]'
                    fi
                done
                if ! $found; then
                    marked+=( $selected )
                fi
                ;;
            e|l|$'\n'|$'\e[C') # enter, right arrow
                local marked_strings=()
                for m in "${marked[@]}"; do
                    (( m != selected )) && marked_strings+=("${!m}")
                done
                start_editor "${!selected}" "${marked_strings[@]}"
                clear_next=true
                ;;
            r)
                local marked_strings=()
                for m in "${marked[@]}"; do
                    (( m != selected )) && marked_strings+=("${!m}")
                done
                start_scanner true "${!selected}" "${marked_strings[@]}"
                clear_next=true
                ;;
            f)
                local marked_strings=()
                for m in "${marked[@]}"; do
                    (( m != selected )) && marked_strings+=("${!m}")
                done
                start_scanner false "${!selected}" "${marked_strings[@]}"
                clear_next=true
                ;;
            q|$'\x1b')
                clean_exit
                ;;
        esac
    done
}

bulk_rename() {
    local template=$1; shift
    for opt; do
        local extension="${opt##*.}"
        local newname=$template

        # read data
        data=()
        read_data "$opt"
        declare -A fields=()
        for field in "${!data[@]}"; do
            if [[ -v "specifiers[$field]" ]]; then
                local specifier=${specifiers[$field]}
                if ! [[ -v "fields[$specifier]" ]]; then
                    fields[$specifier]=${data[$field]}
                fi
            fi
        done
        # work-around for mid3v2's lack of tracktotal field
        if [[ $extension == "mp3" ]] && ! [[ -v "fields['l']" ]]; then
            local track="${fields['n']}"
            local x=$(strindex "$track" "/")
            if (( x > 0 )); then
                fields['n']=${track%\/*}
                fields['l']=${track##*\/}
            fi
        fi

        # replace specifiers with data
        for s in "${specifiers[@]}"; do
            if [[ $input =~ .*%${s}.* ]]; then
                local substitution=$(echo "${fields[$s]}" | \
                    sed -e 's/&/\\&/g' -e 's;/;\\/;g')
                newname=$(echo $newname | sed "s/%${s}/${substitution}/g")
            fi
        done

        printf '%s\n' "$opt"
        printf ' -> %s.%s : ' "$newname" "$extension"
        newname=${newname/#~/$HOME}  # tilde expansion
        if [[ -z "${newname// }" ]]; then
            printf '%s empty file name. \e[0m\n' "$CURSEDTAG_COLOR_ERROR"
        elif [[ $opt == "$newname.$extension" ]]; then
            printf 'unchanged.\n'
        elif [[ -f "$newname.$extension" ]]; then
            printf '%s file exists. \e[0m\n' "$CURSEDTAG_COLOR_ERROR"
        else
            mkdir -p -- "$(dirname "$newname")"
            if ! mv -n -- "$opt" "$newname.$extension" &> /dev/null; then
                printf '%s could not rename. \e[0m\n' \
                    "$CURSEDTAG_COLOR_ERROR"
            else
                printf '%s renamed. \e[0m\n' "$CURSEDTAG_COLOR_SUCCESS"
                preselected=$newname.$extension
                file_renamed=true
            fi
        fi
        printf '\n'
    done
}

fill_tags() {
    local input=$1; shift
    for opt; do
        local regexp="$(echo $input | \
                sed -e 's,/,\\/,g ; s,|,\\|,g' \
                -e 's/(/\\(/g ; s/)/\\)/g ; s/\[/\\[/g ; s/\]/\\]/g')"
        local order_of_specifiers=()
        for tag in "${!specifiers[@]}"; do
            local specifier=${specifiers[$tag]}
            if [[ $input =~ .*%${specifier}.* ]]; then
                local x=$(strindex "$input" "%${specifier}")
                regexp="$(echo $regexp | sed "s/%${specifier}/\(.*?\)/g")"
                if (( x >= 0 )); then
                    order_of_specifiers[$x]=$tag
                fi
            fi
        done

        local idx=1
        local replacement=()
        for s in "${order_of_specifiers[@]}"; do
            replacement+=("${s}=\\${idx}")
            ((idx++))
        done
        local parent_name=""
        local parent=""
        local filename="${opt%.*}"
        local slashes="${regexp//[^\/]}"
        local slashes_count=${#slashes}
        ((slashes_count > 0 )) && for ((i=1; i<=slashes_count; i++)); do
            parent_name="$(basename "${parent:-$PWD}")"
            if ! [[ $parent_name == "/" ]]; then
                filename=${parent_name}/${filename}
            else
                filename=/$filename
                break
            fi
            parent=$(dirname "${parent:-$PWD}")
        done
        if (( ${#replacement[@]} )); then
            local replacement_str=$(join_by "^" "${replacement[@]}")
            output=$(echo $filename | \
                perl -ne "print if s|^${regexp}$|${replacement_str}|")
            if [[ -n "$output" ]]; then
                printf '%s\n' "$opt"
                while IFS= read -r -d '^' line; do
                    local field=${line%=*}
                    local value=${line##*=}
                    local tag=$(arrayindex $field specifiers)
                    set_field "$field" "$value" "$opt"
                    printf '    %s[%s]\e[0m = %s\n' "$CURSEDTAG_COLOR_OPTION" \
                        "$field" "$value"
                done <<< "${output}^"
                printf '\n'
            fi
        fi
    done
}

start_scanner() {
    local rename_mode=$1; shift
    local input=${CURSEDTAG_DEFAULT_TEMPLATE}
    local cursor=${#input}
    local preview=""

    # read data
    data=()
    data_state=()
    read_data "$1"
    declare -A fields=()
    for field in "${!data[@]}"; do
        if [[ -v "specifiers[$field]" ]]; then
            local specifier=${specifiers[$field]}
            if ! [[ -v "fields[$specifier]" ]]; then
                fields[$specifier]=${data[$field]}
            fi
        fi
    done
    # work-around for mid3v2's lack of tracktotal field
    if ! [[ -v "fields['l']" ]]; then
        local track="${fields['n']}"
        local x=$(strindex "$track" "/")
        if (( x > 0 )); then
            fields['n']=${track%\/*}
            fields['l']=${track##*\/}
        fi
    fi

    local legend=()
    for s in "${!specifiers[@]}"; do
        legend+=("%${specifiers[$s]}: ${fieldmapping[$s]}")
    done
    IFS=$'\n' sorted_legend=($(sort <<< "${legend[*]}"))

    hide_cursor
    clear_screen
    print_status_line "$@"

    move_cursor 5
    printf 'Legend\n'
    for n in "${sorted_legend[@]}"; do
        printf '  %s\n' "$n"
    done

    while true; do
        if $rename_mode; then
            preview=$input
            # replace specifiers with data
            for s in "${specifiers[@]}"; do
                if [[ $preview =~ .*%${s}.* ]]; then
                    local substitution=$(echo ${fields[$s]} |\
                        sed -e 's/&/\\&/g' -e 's;/;\\/;g')
                    if [[ -z $substitution ]]; then
                        substitution="[…]"
                    fi
                    preview=$(echo $preview | \
                        sed "s/%${s}/${substitution}/g")
                fi
            done
        else
            # parse filename according to template
            preview=""
            local regexp="$(echo $input | \
                    sed -e 's,/,\\/,g ; s,|,\\|,g' \
                    -e 's/(/\\(/g ; s/)/\\)/g ; s/\[/\\[/g ; s/\]/\\]/g')"
            local order=()
            for s in "${specifiers[@]}"; do
                if [[ $input =~ .*%${s}.* ]]; then
                    local x=$(strindex "$input" "%${s}")
                    regexp="$(echo $regexp | sed "s/%${s}/\(.*?\)/g")"
                    if (( x >= 0 )); then
                        order[$x]=$s
                    fi
                fi
            done

            local idx=1
            local replacement=()
            for s in "${order[@]}"; do
                replacement+=("%${s}=\\${idx}")
                ((idx++))
            done
            local parent_name=""
            local parent=""
            local filename="${1%.*}"
            local slashes="${regexp//[^\/]}"
            local slashes_count=${#slashes}
            ((slashes_count > 0 )) && for ((i=1; i<=slashes_count; i++)); do
                parent_name="$(basename "${parent:-$PWD}")"
                if ! [[ $parent_name == "/" ]]; then
                    filename=${parent_name}/${filename}
                else
                    filename=/$filename
                    break
                fi
                parent=$(dirname "${parent:-$PWD}")
            done
            if (( ${#replacement[@]} )); then
                local replacement_str=$(join_by " " "${replacement[@]}")
                output=$(echo $filename | \
                    perl -ne "print if s|^${regexp}$|${replacement_str}|")
                [[ -n "$output" ]] && \
                    preview=$output
            fi
        fi

        # erase only lines that change to avoid too much clear_screen
        hide_cursor
        clear_line 2
        clear_line 3
        clear_line 4
        move_cursor 2
        printf ' > %s\n' "$input"
        printf '   \e[32m%s\e[0m\n\n' "$preview"
        move_cursor 2 $((4 + cursor))
        show_cursor

        # catch multi-char special key sequences
        read -sN1 key
        read -sN1 -t 0.0001 k1
        read -sN1 -t 0.0001 k2
        read -sN1 -t 0.0001 k3
        key+=${k1}${k2}${k3}
        case "$key" in
            $'\e[D')
                # left arrow
                ((cursor > 0 )) && ((cursor--))
                ;;
            $'\e[C') # right arrow
                ((cursor < ${#input} )) && ((cursor++))
                ;;
            $'\ca'|$'\e[1~'|$'\e0H'|$'\e[H') # home
                cursor=0
                ;;
            $'\ce'|$'\e[4~'|$'\e0F'|$'\e[F') # end
                cursor=${#input}
                ;;
            $'\x7f'|$'\177') # backspace
                if (( cursor > 0)); then
                    r=$((cursor - 1))
                    input=${input:0:$r}${input:$cursor:${#input}}
                    cursor=$r
                fi
                ;;
            $'\h'|$'\b') # ctrl+backspace
                input=
                cursor=0
                ;;
            $'\e[3~') # delete
                l=$((cursor + 1))
                input=${input:0:$cursor}${input:$l:${#input}}
                ;;
            ''|$'\n')
                break
                ;;
            $'\x1b') # escape
                return
                ;;
            *)
                if ! [[ $key =~ [[:cntrl:]] ]]; then
                    input=${input:0:$cursor}$key${input:$cursor:${#input}}
                    cursor=$((cursor + ${#key}))
                fi
                ;;
        esac
    done

    # redraw the screen without legend
    clear_screen
    print_status_line "$@"
    printf ' > %s\n' "$input"
    printf '   %s%s\e[0m\n' "$CURSEDTAG_COLOR_SUCCESS" "$preview"
    printf '\n'

    if $rename_mode; then
        bulk_rename "$input" "$@"
    else
        fill_tags "$input" "$@"
    fi

    echo
    echo " [Press enter...]"
    read
}

read_data() {
    read_data_mid3v2 "$@"
    read_data_metaflac "$@"
    read_data_vorbiscomment "$@"
}

read_data_mid3v2() {
    local extension="${1##*.}"
    if [[ $extension == "mp3" ]]; then
        data[size]=$(du -h -- "$1" | awk '{print $1}')
        data[bitrate]=$(sox --i -B -- "$1" 2> /dev/null)
        local secs=$(sox --i -D -- "$1" 2> /dev/null)
        secs="${secs%%.*}"
        data[length]=$(convert_time $secs)

        while read line; do
            local tag=$(echo $line | grep -ao "^....")
            local value=$(echo $line | sed "s/[^ ]*=\(.*\)$/\1/")
            if [[ -v mid3v2_mapping[$tag] ]]; then
                local tagname="${mid3v2_mapping[$tag]}"
                if ! [[ -v "data[$tagname]" ]]; then
                    data[$tagname]=$value
                    data_state[$tagname]=$value
                fi
            fi
        done <<< $(mid3v2 -q -- "$1" | grep -a "^....=" | tr '\0' '=')

        # split TRCK field into track and tracktotal
        if [[ "${data['track']}" == */* ]]; then
            local value=${data['track']}
            data['track']=${value%%/*}
            data['tracktotal']=${value##*/}
            data_state['track']=${data['track']}
            data_state['tracktotal']=${data['tracktotal']}
        fi
    fi
}

read_data_metaflac() {
    local extension="${1##*.}"
    if [[ $extension == "flac" ]]; then
        data[size]=$(du -h -- "$1" | awk '{print $1}')
        data[bitrate]=$(sox --i -B -- "$1" 2> /dev/null)
        local secs=$(sox --i -D -- "$1" 2> /dev/null)
        secs="${secs%%.*}"
        data[length]=$(convert_time $secs)

        while read line; do
            tag=$(echo $line | grep -ao "^[A-Z]*")
            value=$(echo $line | sed "s/[A-Z]*=//")
            if [[ -v vorbis_mapping[$tag] ]]; then
                local tagname="${vorbis_mapping[$tag]}"
                if ! [[ -v "data[$tagname]" ]]; then
                    data[$tagname]=$value
                    data_state[$tagname]=$value
                fi
            fi
        done <<< $(metaflac --list --except-block-type=PICTURE \
            -- "$1" | grep -ao "[A-Z]*=.*")
    fi
}

read_data_vorbiscomment() {
    local extension="${1##*.}"
    if [[ $extension == "ogg" ]]; then
        data[size]=$(du -h -- "$1" | awk '{print $1}')
        data[bitrate]=$(sox --i -B -- "$1" 2> /dev/null)
        local secs=$(sox --i -D -- "$1" 2> /dev/null)
        secs="${secs%%.*}"
        data[length]=$(convert_time $secs)

        while read line; do
            tag=$(echo $line | grep -ao "^[A-Z]*")
            value=$(echo $line | sed "s/[A-Z]*=//")
            if [[ -v vorbis_mapping[$tag] ]]; then
                local tagname="${vorbis_mapping[$tag]}"
                if ! [[ -v "data[$tagname]" ]]; then
                    data[$tagname]=$value
                    data_state[$tagname]=$value
                fi
            fi
        done <<< $(vorbiscomment -l -- "$1" | grep -ao "[A-Z]*=.*")
    fi
}

set_field() {
    set_field_mid3v2 "$@"
    set_field_metaflac "$@"
    set_field_vorbiscomment "$@"
}

set_field_mid3v2() {
    local field=$1; shift
    local value=$1; shift

    local is_track=false
    local is_tracktotal=false
    if [[ $field == "tracktotal" ]]; then
        is_tracktotal=true
    fi
    if [[ $field == "track" ]]; then
        is_track=true
    fi

    local tag=$(arrayindex $field mid3v2_mapping)
    local options=("--delete-frames" "$tag")
    if [[ -n "$value" ]]; then
        options+=("--$tag" "$value")
    fi

    local files=()
    for opt; do
        local extension="${opt##*.}"
        if [[ $extension == "mp3" ]]; then
            if $is_tracktotal; then
                local track_field=$(mid3v2 -q -- "$opt" | sed -n 's/^TRCK=//p')
                local track="${track_field%%/*}"
                local new_value="${track}${value:+/}${value}"
                if [[ -n "$new_value" ]]; then
                    mid3v2 --TRCK "$new_value" -- "$opt"
                else
                    mid3v2 --delete-frames TRCK -- "$opt"
                fi
            elif $is_track; then
                local track_field=$(mid3v2 -q -- "$opt" | sed -n 's/^TRCK=//p')
                local tracktotal="${track_field##*/}"
                local new_value="${value}${tracktotal:+/}${tracktotal}"
                if [[ -n "$new_value" ]]; then
                    mid3v2 --TRCK "$new_value" -- "$opt"
                else
                    mid3v2 --delete-frames TRCK -- "$opt"
                fi
            else
                files+=("$opt")
            fi

        fi
    done
    if (( ${#options[@]} )) && (( ${#files[@]} )); then
        mid3v2 "${options[@]}" -- "${files[@]}"
    fi
}

set_field_metaflac() {
    local field=$1; shift
    local value=$1; shift

    local tag=$(arrayindex $field vorbis_mapping)
    local options=("--remove-tag" "$tag")
    if [[ -n "$value" ]]; then
        options+=("--set-tag" "$tag=$value")
    fi

    local files=()
    for opt; do
        local extension="${opt##*.}"
        if [[ $extension == "flac" ]]; then
            files+=("$opt")
        fi
    done
    if (( ${#options[@]} )) && (( ${#files[@]} )); then
        metaflac "${options[@]}" -- "${files[@]}"
    fi
}

set_field_vorbiscomment() {
    local field=$1; shift
    local value=$1; shift

    local tag=$(arrayindex $field vorbis_mapping)
    options=("--tag" "$tag=$value")

    local files=()
    for opt; do
        local extension="${opt##*.}"
        if [[ $extension == "ogg" ]]; then
            {
                vorbiscomment "$opt" | grep -v "^$tag"
                echo $tag="$value"
            } | vorbiscomment -c - -w -- "$opt"
        fi
    done
}

start_editor() {
    local selected=1
    local offset=1
    local lastoffset=0
    local idx=1
    local extension="${1##*.}"

    local page_step=$((ROWS - 3))
    local list_size=${#fieldorder[@]}

    local is_yanked=false
    local yanked=""

    # read data
    data=()
    data_state=()
    read_data "$1"

    # get widest field name to create nice grid
    local max_field_length=0
    for s in "${fieldorder[@]}"; do
        if [[ ${#fieldmapping[$s]} -gt $max_field_length ]]; then
            local max_field_length=${#fieldmapping[$s]}
        fi
    done
    ((max_field_length++))

    local clear_next=false
    while true; do
        local field_index=$((selected - 1))
        local field=${fieldorder[$field_index]}

        # clear screen if the offset changed
        if $clear_next || [[ $lastoffset != $offset ]]; then
            hide_cursor
            clear_screen
            print_status_line "$(basename "$@")"
            clear_next=false
            printf 'bitrate: %s%-4s\e[0m  ' \
                "$CURSEDTAG_COLOR_OPTION" "${data[bitrate]}"
            printf 'file size: %s%-4s\e[0m  '\
                "$CURSEDTAG_COLOR_OPTION" "${data[size]}"
            printf 'length: %s%s\e[0m\n' \
                "$CURSEDTAG_COLOR_OPTION" "${data[length]}"
        fi

        # print options
        idx=1
        lastoffset=$offset
        for s in "${fieldorder[@]}"; do
            if ((idx >= offset)) && ((idx < offset + max_items)); then
                local fieldname=${fieldmapping[$s]}
                local is_selected=false
                local is_unsaved=false
                [[ $idx == $selected ]] && \
                    is_selected=true
                if ! [[ ${data[$s]} == "${data_state[$s]}" ]]; then
                    is_unsaved=true
                fi
                move_cursor $((3 - offset + idx))  # starting at 3nd row
                printf ' %-*s %s:' "$max_field_length" "$fieldname"
                local dots=$(ellipsis " ${data_state[$s]} " $max_field_length)
                print_option "$is_unsaved" "$is_selected" "$dots"
            fi
            ((idx++))
        done
        read -sN1 key
        read -sN1 -t 0.0001 k1
        read -sN1 -t 0.0001 k2
        read -sN1 -t 0.0001 k3
        key+=${k1}${k2}${k3}
        case "$key" in
            k|$'\e[A')  # up
                if (( selected > 1 )); then
                    ((selected--))
                    if (( selected < offset )); then
                        ((offset--))
                    fi
                fi
                ;;
            j|$'\e[B')  # down
                if (( selected < list_size )); then
                    ((selected++))
                    if (( selected > offset + max_items - 1 )); then
                        ((offset++))
                    fi
                fi
                ;;
            $'\cb'|$'\e[5~')  # page up
                if (( selected - page_step > 1 )); then
                    ((selected-=page_step))
                    if (( selected < offset )); then
                        ((offset-=page_step))
                    fi
                else
                    selected=1
                    offset=1
                fi
                ;;
            $'\cf'|$'\e[6~')  # page down
                if (( selected + page_step < list_size )); then
                    ((selected+=page_step))
                    if (( selected > offset + max_items - 1 )); then
                        ((offset+=page_step))
                    fi
                else
                    selected=$list_size
                    ((offset=list_size - max_items + 1))
                    offset=$((offset > 1 ? offset : 1 ))
                fi
                ;;
            g|$'\e[1~'|$'\e0H'|$'\e[H')  # home
                selected=1
                offset=1
                ;;
            G|$'\e[4~'|$'\e0F'|$'\e[F')  # end
                selected=$list_size
                ((offset=list_size - max_items + 1))
                offset=$((offset > 1 ? offset : 1 ))
                ;;
            i)  # edit (cursor at start)
                editor_prompt_output=""
                editor_prompt false $((selected - offset + 3)) \
                    $max_field_length "${data_state[$field]}"
                data_state[$field]=$editor_prompt_output
                hide_cursor
                clear_line $((selected - offset + 3))
                ;;
            a|$'\n') # edit (cursor at end)
                editor_prompt_output=""
                editor_prompt true $((selected - offset + 3)) \
                    ${max_field_length} "${data_state[$field]}"
                data_state[$field]=$editor_prompt_output
                hide_cursor
                clear_line $((selected - offset + 3))
                ;;
            y)  # yank
                yanked=${data_state[$field]}
                is_yanked=true
                ;;
            p)  # paste
                if $is_yanked; then
                    data_state[$field]=$yanked
                    clear_line $((selected - offset + 3))
                fi
                ;;
            x)  # erase
                data_state[$field]=""
                clear_line $((selected - offset + 3))
                ;;
            u)  # undo
                data_state[$field]=${data[$field]}
                clear_line $((selected - offset + 3))
                ;;
            S|W) # apply field to all files
                clear_next=true
                clear_screen
                print_status_line "$@"
                move_cursor 3 0
                data[$field]=${data_state[$field]}
                set_field "$field" "${data_state[$field]}" "$@"
                printf '%s[%s]\e[0m = %s\n' "$CURSEDTAG_COLOR_OPTION" \
                    "$field" "${data_state[$field]}"
                printf '    %s\n' "${@}"
                print
                echo
                echo " [Press enter...]"
                read
                ;;
            s|w) # save
                clear_next=true
                clear_screen
                print_status_line "$@"
                move_cursor 3 0
                printf '%s\n' "$1"
                for n in "${!data_state[@]}"; do
                    if ! [[ "${data_state[$n]}" == "${data[$n]}" ]]; then
                        data[$n]=${data_state[$n]}
                        set_field "$n" "${data_state[$n]}" "$1"
                        printf '    %s[%s]\e[0m = %s\n' \
                            "$CURSEDTAG_COLOR_OPTION" "$n" "${data[$n]}"
                    fi
                done
                echo
                echo " [Press enter...]"
                read
                ;;
            h|$'\e[D'|$'\x1b')  # back to selector
                return
                ;;
            q) # quit
                clean_exit
                ;;
        esac
    done
}

clean_exit() {
    # ask for quit?
    reset_terminal
    show_cursor
    trap '' EXIT
    trap '' WINCH
    echo >&2 $2
    exit $1
}

start() {
    local file=$1; shift
    local path=$file

    get_term_size
    setup_terminal
    trap 'get_term_size; ' WINCH
    trap 'reset_terminal' EXIT

    if [[ -f "$file" ]]; then
        preselected=$(basename "$file")
        path=$(dirname "$file")
        start_editor "$file"
        clear
    fi

    builtin cd "$path"
    while true; do
        local audio_files=()
        # mp3 support check
        [[ -x "$(command -v mid3v2)" ]] && while IFS=  read -r -d $'\0'; do
            audio_files+=("$(basename "$REPLY")")
        done < <(find . -maxdepth 1 -type f -name "*.mp3" -print0)

        # flac support check
        [[ -x "$(command -v metaflac)" ]] && while IFS=  read -r -d $'\0'; do
            audio_files+=("$(basename "$REPLY")")
        done < <(find . -maxdepth 1 -type f -name "*.flac" -print0)

        # ogg support check
        [[ -x "$(command -v ogginfo)" ]] && while IFS=  read -r -d $'\0'; do
            audio_files+=("$(basename "$REPLY")")
        done < <(find . -maxdepth 1 -type f -name "*.ogg" -print0)

        (( ${#audio_files[@]} )) || \
            clean_exit 1 "No supported audio files found."
        start_selector "${audio_files[@]}"
    done
}

# main
arg=${1:-"."}
if [[ -n "$arg" ]]; then
    if [[ -e "$arg" ]]; then
        start "$arg"
    else
        echo >&2 "File not found."
        exit 1
    fi
fi
